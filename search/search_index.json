{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"zend-eventmanager zend-eventmanager is designed for the following use cases: Implementing simple subject/observer patterns. Implementing Aspect-Oriented designs. Implementing event-driven architectures. The basic architecture allows you to attach and detach listeners to named events, both on a per-instance basis as well as via shared collections; trigger events; and interrupt execution of listeners. File issues at https://github.com/zendframework/zend-eventmanager/issues Documentation is at https://zendframework.github.io/zend-eventmanager/ For migration from version 2 to version 3, please read the migration documentation . Benchmarks We provide scripts for benchmarking zend-eventmanager using the Athletic framework; these can be found in the benchmarks/ directory. To execute the benchmarks you can run the following command: $ vendor/bin/athletic -p benchmarks","title":"Home"},{"location":"#zend-eventmanager","text":"zend-eventmanager is designed for the following use cases: Implementing simple subject/observer patterns. Implementing Aspect-Oriented designs. Implementing event-driven architectures. The basic architecture allows you to attach and detach listeners to named events, both on a per-instance basis as well as via shared collections; trigger events; and interrupt execution of listeners. File issues at https://github.com/zendframework/zend-eventmanager/issues Documentation is at https://zendframework.github.io/zend-eventmanager/ For migration from version 2 to version 3, please read the migration documentation .","title":"zend-eventmanager"},{"location":"#benchmarks","text":"We provide scripts for benchmarking zend-eventmanager using the Athletic framework; these can be found in the benchmarks/ directory. To execute the benchmarks you can run the following command: $ vendor/bin/athletic -p benchmarks","title":"Benchmarks"},{"location":"aggregates/","text":"Listener Aggregates Listener aggregates exist to facilitate two operations: Attaching many listeners at once. Attaching stateful listeners. A listener aggregate is a class implementing Zend\\EventManager\\ListenerAggregateInterface , which defines two methods: attach(EventManagerInterface $events, $priority = 1); detach(EventManagerInterface $events); To attach an aggregate to an event manager, you pass the event manager to the aggregate's attach() method; in that method, you will then attach listeners to the events you are interested in. Implementation To implement ListenerAggregateInterface , you need to define the attach() and detach() methods. A typical implementation will look something like this: use Zend\\EventManager\\EventInterface; use Zend\\EventManager\\EventManagerInterface; use Zend\\EventManager\\ListenerAggregateInterface; class Aggregate implements ListenerAggregateInterface { private $listeners = []; public function attach(EventManagerInterface $events, $priority = 1) { $this->listeners[] = $events->attach('something', [$this, 'onSomething'], $priority); $this->listeners[] = $events->attach('else', [$this, 'onElse'], $priority); $this->listeners[] = $events->attach('again', [$this, 'onAgain'], $priority); } public function detach(EventManagerInterface $events) { foreach ($this->listeners as $index => $listener) { $events->detach($listener); unset($this->listeners[$index]); } } public function onSomething(EventInterface $event) { // handle event } public function onElse(EventInterface $event) { // handle event } public function onAgain(EventInterface $event) { // handle event } } Because the logic for detaching is essentially the same in all implementations, we provide two facilities for implementing this: Zend\\EventManager\\AbstractListenerAggregate is an abstract class that defines the $listeners property and the detach() method. You may extend it in order to create an implementation. Zend\\EventManager\\ListenerAggregateTrait is a trait that defines the $listeners property and the detach() method. You may implement Zend\\EventManager\\ListenerAggregateInterface and use this trait to implement the detach() logic. Usage To use an aggregate listener, you need to attach it to the event manager. As noted in the intro to this section, you do so by passing the event manager to the aggregate's attach() method: // Assume $events is an EventManager instance, and $aggregate is an instance of // the Aggregate class defined earlier. $aggregate->attach($events); Recommendations We recommend using listener aggregates when you have several listeners that are related and/or share common dependencies and/or business logic. This helps keep the logic in the same location, and helps reduce dependencies. We recommend using the verbiage on<Event Name> to name your listener methods. This helps hint that they will be triggered on an event , and semantically ties them to the specific event name.","title":"Listener Aggregates"},{"location":"aggregates/#listener-aggregates","text":"Listener aggregates exist to facilitate two operations: Attaching many listeners at once. Attaching stateful listeners. A listener aggregate is a class implementing Zend\\EventManager\\ListenerAggregateInterface , which defines two methods: attach(EventManagerInterface $events, $priority = 1); detach(EventManagerInterface $events); To attach an aggregate to an event manager, you pass the event manager to the aggregate's attach() method; in that method, you will then attach listeners to the events you are interested in.","title":"Listener Aggregates"},{"location":"aggregates/#implementation","text":"To implement ListenerAggregateInterface , you need to define the attach() and detach() methods. A typical implementation will look something like this: use Zend\\EventManager\\EventInterface; use Zend\\EventManager\\EventManagerInterface; use Zend\\EventManager\\ListenerAggregateInterface; class Aggregate implements ListenerAggregateInterface { private $listeners = []; public function attach(EventManagerInterface $events, $priority = 1) { $this->listeners[] = $events->attach('something', [$this, 'onSomething'], $priority); $this->listeners[] = $events->attach('else', [$this, 'onElse'], $priority); $this->listeners[] = $events->attach('again', [$this, 'onAgain'], $priority); } public function detach(EventManagerInterface $events) { foreach ($this->listeners as $index => $listener) { $events->detach($listener); unset($this->listeners[$index]); } } public function onSomething(EventInterface $event) { // handle event } public function onElse(EventInterface $event) { // handle event } public function onAgain(EventInterface $event) { // handle event } } Because the logic for detaching is essentially the same in all implementations, we provide two facilities for implementing this: Zend\\EventManager\\AbstractListenerAggregate is an abstract class that defines the $listeners property and the detach() method. You may extend it in order to create an implementation. Zend\\EventManager\\ListenerAggregateTrait is a trait that defines the $listeners property and the detach() method. You may implement Zend\\EventManager\\ListenerAggregateInterface and use this trait to implement the detach() logic.","title":"Implementation"},{"location":"aggregates/#usage","text":"To use an aggregate listener, you need to attach it to the event manager. As noted in the intro to this section, you do so by passing the event manager to the aggregate's attach() method: // Assume $events is an EventManager instance, and $aggregate is an instance of // the Aggregate class defined earlier. $aggregate->attach($events);","title":"Usage"},{"location":"aggregates/#recommendations","text":"We recommend using listener aggregates when you have several listeners that are related and/or share common dependencies and/or business logic. This helps keep the logic in the same location, and helps reduce dependencies. We recommend using the verbiage on<Event Name> to name your listener methods. This helps hint that they will be triggered on an event , and semantically ties them to the specific event name.","title":"Recommendations"},{"location":"api/","text":"EventManager API This section details the public API of the EventManager , SharedEventManager , EventInterface , and ResponseCollection . EventManager Constructor public function __construct( SharedEventManagerInterface $sharedEvents = null, array $identifiers = [] ) The EventManager instance accepts a shared event manager instance and identifiers to use with the shared event manager. setEventPrototype() public function setEventPrototype(EventInterface $event) : void Use this method in order to provide an event prototype. The event prototype is used with the trigger() and triggerUntil() methods to create a new event instance; the prototype is cloned and populated with the event name, target, and arguments passed to the method. getSharedManager() public function getSharedManager() : null|SharedEventManagerInterface Use this method to retrieve the composed shared event manager instance, if any. getIdentifiers() public function getIdentifiers() : array Use this method to retrieve the current list of identifiers the event manager defines. Identifiers are used when retrieving listeners from the composed shared event manager. setIdentifiers() and addIdentifiers() public function setIdentifiers(array $identifiers) : void public function addIdentifiers(array $identifiers) : void Use these methods to manipulate the list of identifiers the event manager is interested in. setIdentifiers() will overwrite any identifiers previously set, while addIdentifiers() will merge them. trigger() trigger($eventName, $target = null, $argv = []) : ResponseCollection where: $eventName is a string event name. $target is the target of the event; usually the object composing the event manager instance. $argv is an array or ArrayAccess instance of arguments that provide context for the event. Typically these will be the arguments passed to the function in which the trigger call occurs. The target and/or arguments may be omitted, but the event name is required. When done triggering, the method returns a ResponseCollection . triggerUntil() triggerUntil(callable $callback, $eventName, $target = null, $argv = []) : ResponseCollection triggerUntil() is a sibling to trigger() , and prefixes the argument list with a single $callback . The $callback is invoked after each listener completes, with the result of that listener. The $callback should inspect the result, and determine if it should result in short-circuiting the event loop. Returning a boolean true value indicates that the criteria has been met and the event loop should end. As an example: $events->attach('foo', function ($e) { echo \"Triggered first\\n\"; return true; }); $events->attach('foo', function ($e) { echo \"Triggered second\\n\"; return false; }); $events->attach('foo', function ($e) { echo \"Triggered third\\n\"; return true; }); $events->triggerUntil(function ($result) { return (false === $result); }, 'foo'); In the above example, the event loop will short-circuit after the second listener executes, resulting in the following output: Triggered first Triggered second triggerEvent() triggerEvent(EventInterface $event) : ResponseCollection This method is a sibling to trigger() , but unlike trigger() , it accepts an EventInterface instance as its sole argument. It is up to the caller to ensure the event is properly populated. This method behaves identically to trigger() , returning a ResponseCollection after all listeners have been triggered. triggerEventUntil() triggerEventUntil(callable $callback, EventInterface $event) : ResponseCollection This method is a sibling to triggerEvent() and triggerUntil() . Like triggerUntil() , the first argument is a PHP callable to invoke for each response, and is used to determine whether or not to short-circuit execution. Like triggerEvent() , the next argument is an EventInterface instance. attach() attach($eventName, callable $listener, $priority = 1) : callable Use attach() to attach a callable listener to a named event. $priority can be used to indicate where in the listener queue the event should be executed. Priorities must be integers. High positive integers indicate higher priority (will execute first), while low, negative integers indicate lower priority (will execute last). The default priority is 1, and listeners registered with the same priority will execute in the order in which they attach to the event manager. The method returns the listener attached. detach() detach(callable $listener, $eventName = null) : void Use detach() to remove a listener. When a named $eventName is provided, the method will detach the listener from that event only (or, if the event does not exist in the event manager, nothing will occur). If no event is provided, or the wildcard event is provided, the listener will be detached from all events. clearListeners() clearListeners($eventName) : void Use this method to remove all listeners for a given named event. prepareArgs() prepareArgs(array $args) : ArrayObject Normally when working with an event, if you want to change any arguments in the event, you would need to do the following: $args = $e->getParams(); // Manipulate args: $args['foo'] = 'bar'; // Pass them back in: $e->setParams($args); If the arguments you provide are an object , however, you can manipulate them directly: $args = $e->getParams(); // Manipulate args: $args->foo = 'bar'; // Done! Using an object, however, makes accessing individual parameters difficult: $foo = $e->getParam('foo'); // How should the event know how to get this? As such, we recommend passing either an array or an ArrayObject instance for event arguments. If you pass the latter, you get the benefit of being able to manipulate by reference. prepareArgs() can thus be used to return an ArrayObject representation of your arguments to pass to trigger() or triggerUntil() : $events->attach('foo', $this, $events->prepareArgs(compact('bar', 'baz'))); SharedEventManager attach() attach($identifier, $eventName, callable $listener, $priority = 1) : void Attach a listener to a named event triggered by an identified context, where: $identifier is a string identifier that may be defined by an EventManager instance; $identifier may be the wildcard * . $eventName is a string event name (or the wildcard * ). $listener is a PHP callable that will listen for an event. $priority is the priority to use when attaching the listener. detach() detach(callable $listener, $identifier = null, $eventName = null) : void Detach a listener, optionally from a single identifier, and optionally from a named event, where: $listener is the PHP callable listener to detach. $identifier is a string identifier from which to detach. $eventName is a string event name from which to detach. If no or a null $identifier is provided, the listener will be detached from all identified contexts. If no or a null $eventName is provided, the listener will be detached from all named events discovered. getListeners() getListeners(array $identifiers, $eventName = null) : array[] Retrieves all registered listeners for a given identifier and named event; if the event name is omitted, it returns all listeners for the identifier. Each value in the array returned is in the form: [ 'listener' => callable, 'priority' => int, ] Implementations should return wildcard listeners in this array. This method is used by the EventManager in order to get a set of listeners for the event being triggered. clearListeners() clearListeners($id, $eventName = null) : bool This event will clear all listeners for a given identifier, or, if specified, the specific event for the named identifier. EventInterface In most cases, you will use Zend\\EventManager\\Event , but some components will define custom events. The EventInterface thus defines the common methods across any event implementation. getName() getName() : string Returns the event name. getTarget() getTarget() : null|string|object Returns the event target, if any. getParams() getParams() : array|ArrayAccess Returns the event parameters, if any. getParam() getParam($name, $default = null) : mixed Returns a single named parameter, returning the $default if not found. setName() setName($name) : void Sets the event name. setTarget() setTarget($target) : void Sets the event target. $target may be a string or object. setParams() setParams($params) : void Set the event parameters; $params should be an array or object implementing ArrayAccess . setParam() setParam($name, $value) : void Set a single named event parameter value. stopPropagation() stopPropagation($flag = true) : void Indicate whether or not event propagation should halt (short-circuit). This value is what will be returned by propagationIsStopped() . propagationIsStopped() propagationIsStopped() : bool Used by the event manager to determine if the event has indicated that the event loop should short-circuit. ResponseCollection A ResponseCollection instance is returned by each of trigger() , triggerUntil() , triggerEvent() , and triggerEventUntil() , and represents the various results of listener execution. The ResponseCollection is iterable, and iteration will return the various responses in the order in which they were provided. In addition, it has the API listed below. stopped() stopped() : bool Use this to determine if something caused the event loop to short-circuit. first() first() : mixed Returns the result from the first listener executed. last() last() : mixed Returns the result from the last listener executed. contains() contains($value) : bool Query the response collection to determine if a specific value was returned by any listener.","title":"EventManager API"},{"location":"api/#eventmanager-api","text":"This section details the public API of the EventManager , SharedEventManager , EventInterface , and ResponseCollection .","title":"EventManager API"},{"location":"api/#eventmanager","text":"","title":"EventManager"},{"location":"api/#constructor","text":"public function __construct( SharedEventManagerInterface $sharedEvents = null, array $identifiers = [] ) The EventManager instance accepts a shared event manager instance and identifiers to use with the shared event manager.","title":"Constructor"},{"location":"api/#seteventprototype","text":"public function setEventPrototype(EventInterface $event) : void Use this method in order to provide an event prototype. The event prototype is used with the trigger() and triggerUntil() methods to create a new event instance; the prototype is cloned and populated with the event name, target, and arguments passed to the method.","title":"setEventPrototype()"},{"location":"api/#getsharedmanager","text":"public function getSharedManager() : null|SharedEventManagerInterface Use this method to retrieve the composed shared event manager instance, if any.","title":"getSharedManager()"},{"location":"api/#getidentifiers","text":"public function getIdentifiers() : array Use this method to retrieve the current list of identifiers the event manager defines. Identifiers are used when retrieving listeners from the composed shared event manager.","title":"getIdentifiers()"},{"location":"api/#setidentifiers-and-addidentifiers","text":"public function setIdentifiers(array $identifiers) : void public function addIdentifiers(array $identifiers) : void Use these methods to manipulate the list of identifiers the event manager is interested in. setIdentifiers() will overwrite any identifiers previously set, while addIdentifiers() will merge them.","title":"setIdentifiers() and addIdentifiers()"},{"location":"api/#trigger","text":"trigger($eventName, $target = null, $argv = []) : ResponseCollection where: $eventName is a string event name. $target is the target of the event; usually the object composing the event manager instance. $argv is an array or ArrayAccess instance of arguments that provide context for the event. Typically these will be the arguments passed to the function in which the trigger call occurs. The target and/or arguments may be omitted, but the event name is required. When done triggering, the method returns a ResponseCollection .","title":"trigger()"},{"location":"api/#triggeruntil","text":"triggerUntil(callable $callback, $eventName, $target = null, $argv = []) : ResponseCollection triggerUntil() is a sibling to trigger() , and prefixes the argument list with a single $callback . The $callback is invoked after each listener completes, with the result of that listener. The $callback should inspect the result, and determine if it should result in short-circuiting the event loop. Returning a boolean true value indicates that the criteria has been met and the event loop should end. As an example: $events->attach('foo', function ($e) { echo \"Triggered first\\n\"; return true; }); $events->attach('foo', function ($e) { echo \"Triggered second\\n\"; return false; }); $events->attach('foo', function ($e) { echo \"Triggered third\\n\"; return true; }); $events->triggerUntil(function ($result) { return (false === $result); }, 'foo'); In the above example, the event loop will short-circuit after the second listener executes, resulting in the following output: Triggered first Triggered second","title":"triggerUntil()"},{"location":"api/#triggerevent","text":"triggerEvent(EventInterface $event) : ResponseCollection This method is a sibling to trigger() , but unlike trigger() , it accepts an EventInterface instance as its sole argument. It is up to the caller to ensure the event is properly populated. This method behaves identically to trigger() , returning a ResponseCollection after all listeners have been triggered.","title":"triggerEvent()"},{"location":"api/#triggereventuntil","text":"triggerEventUntil(callable $callback, EventInterface $event) : ResponseCollection This method is a sibling to triggerEvent() and triggerUntil() . Like triggerUntil() , the first argument is a PHP callable to invoke for each response, and is used to determine whether or not to short-circuit execution. Like triggerEvent() , the next argument is an EventInterface instance.","title":"triggerEventUntil()"},{"location":"api/#attach","text":"attach($eventName, callable $listener, $priority = 1) : callable Use attach() to attach a callable listener to a named event. $priority can be used to indicate where in the listener queue the event should be executed. Priorities must be integers. High positive integers indicate higher priority (will execute first), while low, negative integers indicate lower priority (will execute last). The default priority is 1, and listeners registered with the same priority will execute in the order in which they attach to the event manager. The method returns the listener attached.","title":"attach()"},{"location":"api/#detach","text":"detach(callable $listener, $eventName = null) : void Use detach() to remove a listener. When a named $eventName is provided, the method will detach the listener from that event only (or, if the event does not exist in the event manager, nothing will occur). If no event is provided, or the wildcard event is provided, the listener will be detached from all events.","title":"detach()"},{"location":"api/#clearlisteners","text":"clearListeners($eventName) : void Use this method to remove all listeners for a given named event.","title":"clearListeners()"},{"location":"api/#prepareargs","text":"prepareArgs(array $args) : ArrayObject Normally when working with an event, if you want to change any arguments in the event, you would need to do the following: $args = $e->getParams(); // Manipulate args: $args['foo'] = 'bar'; // Pass them back in: $e->setParams($args); If the arguments you provide are an object , however, you can manipulate them directly: $args = $e->getParams(); // Manipulate args: $args->foo = 'bar'; // Done! Using an object, however, makes accessing individual parameters difficult: $foo = $e->getParam('foo'); // How should the event know how to get this? As such, we recommend passing either an array or an ArrayObject instance for event arguments. If you pass the latter, you get the benefit of being able to manipulate by reference. prepareArgs() can thus be used to return an ArrayObject representation of your arguments to pass to trigger() or triggerUntil() : $events->attach('foo', $this, $events->prepareArgs(compact('bar', 'baz')));","title":"prepareArgs()"},{"location":"api/#sharedeventmanager","text":"","title":"SharedEventManager"},{"location":"api/#attach_1","text":"attach($identifier, $eventName, callable $listener, $priority = 1) : void Attach a listener to a named event triggered by an identified context, where: $identifier is a string identifier that may be defined by an EventManager instance; $identifier may be the wildcard * . $eventName is a string event name (or the wildcard * ). $listener is a PHP callable that will listen for an event. $priority is the priority to use when attaching the listener.","title":"attach()"},{"location":"api/#detach_1","text":"detach(callable $listener, $identifier = null, $eventName = null) : void Detach a listener, optionally from a single identifier, and optionally from a named event, where: $listener is the PHP callable listener to detach. $identifier is a string identifier from which to detach. $eventName is a string event name from which to detach. If no or a null $identifier is provided, the listener will be detached from all identified contexts. If no or a null $eventName is provided, the listener will be detached from all named events discovered.","title":"detach()"},{"location":"api/#getlisteners","text":"getListeners(array $identifiers, $eventName = null) : array[] Retrieves all registered listeners for a given identifier and named event; if the event name is omitted, it returns all listeners for the identifier. Each value in the array returned is in the form: [ 'listener' => callable, 'priority' => int, ] Implementations should return wildcard listeners in this array. This method is used by the EventManager in order to get a set of listeners for the event being triggered.","title":"getListeners()"},{"location":"api/#clearlisteners_1","text":"clearListeners($id, $eventName = null) : bool This event will clear all listeners for a given identifier, or, if specified, the specific event for the named identifier.","title":"clearListeners()"},{"location":"api/#eventinterface","text":"In most cases, you will use Zend\\EventManager\\Event , but some components will define custom events. The EventInterface thus defines the common methods across any event implementation.","title":"EventInterface"},{"location":"api/#getname","text":"getName() : string Returns the event name.","title":"getName()"},{"location":"api/#gettarget","text":"getTarget() : null|string|object Returns the event target, if any.","title":"getTarget()"},{"location":"api/#getparams","text":"getParams() : array|ArrayAccess Returns the event parameters, if any.","title":"getParams()"},{"location":"api/#getparam","text":"getParam($name, $default = null) : mixed Returns a single named parameter, returning the $default if not found.","title":"getParam()"},{"location":"api/#setname","text":"setName($name) : void Sets the event name.","title":"setName()"},{"location":"api/#settarget","text":"setTarget($target) : void Sets the event target. $target may be a string or object.","title":"setTarget()"},{"location":"api/#setparams","text":"setParams($params) : void Set the event parameters; $params should be an array or object implementing ArrayAccess .","title":"setParams()"},{"location":"api/#setparam","text":"setParam($name, $value) : void Set a single named event parameter value.","title":"setParam()"},{"location":"api/#stoppropagation","text":"stopPropagation($flag = true) : void Indicate whether or not event propagation should halt (short-circuit). This value is what will be returned by propagationIsStopped() .","title":"stopPropagation()"},{"location":"api/#propagationisstopped","text":"propagationIsStopped() : bool Used by the event manager to determine if the event has indicated that the event loop should short-circuit.","title":"propagationIsStopped()"},{"location":"api/#responsecollection","text":"A ResponseCollection instance is returned by each of trigger() , triggerUntil() , triggerEvent() , and triggerEventUntil() , and represents the various results of listener execution. The ResponseCollection is iterable, and iteration will return the various responses in the order in which they were provided. In addition, it has the API listed below.","title":"ResponseCollection"},{"location":"api/#stopped","text":"stopped() : bool Use this to determine if something caused the event loop to short-circuit.","title":"stopped()"},{"location":"api/#first","text":"first() : mixed Returns the result from the first listener executed.","title":"first()"},{"location":"api/#last","text":"last() : mixed Returns the result from the last listener executed.","title":"last()"},{"location":"api/#contains","text":"contains($value) : bool Query the response collection to determine if a specific value was returned by any listener.","title":"contains()"},{"location":"examples/","text":"Examples Modifying Arguments Occasionally it can be useful to allow listeners to modify the arguments they receive so that later listeners or the calling method will receive those changed values. As an example, you might want to pre-filter a date that you know will arrive as a string and convert it to a DateTime argument. To do this, you can pass your arguments to prepareArgs() , and pass this new object when triggering an event. You will then pull that value back into your method. use DateTime; class ValueObject { // assume a composed event manager function inject(array $values) { $argv = compact('values'); $argv = $this->getEventManager()->prepareArgs($argv); $this->getEventManager()->trigger(__FUNCTION__, $this, $argv); $date = isset($argv['values']['date']) ? $argv['values']['date'] : new DateTime('now'); // ... } } $v = new ValueObject(); $v->getEventManager()->attach('inject', function($e) { $values = $e->getParam('values'); if (! $values) { return; } $values['date'] = isset($values['date']) ? new DateTime($values['date']) : new DateTime('now'); $e->setParam('values', $values); }); $v->inject([ 'date' => '2011-08-10 15:30:29', ]); Short Circuiting One common use case for events is to trigger listeners until either one indicates no further processing should be done, or until a return value meets specific criteria. As an example, a request listener might be able to return a response object, and would signal to the target to stop event propagation. $listener = function($e) { // do some work // Stop propagation and return a response $e->stopPropagation(true); return $response; }; Alternately, the request handler could halt execution at the first listener that returns a response. class Foo implements DispatchableInterface { // assume composed event manager public function dispatch(Request $request, Response $response = null) { $argv = compact('request', 'response'); $results = $this->getEventManager()->triggerUntil(function($v) { return ($v instanceof Response); }, __FUNCTION__, $this, $argv); } } Typically, you may want to return the value that stopped execution, or use it some way. All trigger*() methods return a ResponseCollection instance; call its stopped() method to test if execution was stopped, and the last() method to retrieve the return value from the last executed listener: class Foo implements DispatchableInterface { // assume composed event manager public function dispatch(Request $request, Response $response = null) { $argv = compact('request', 'response'); $results = $this->getEventManager()->triggerUntil(function($v) { return ($v instanceof Response); }, __FUNCTION__, $this, $argv); // Test if execution was halted, and return last result: if ($results->stopped()) { return $results->last(); } // continue... } } Assigning Priority to Listeners One use case for the EventManager is for implementing caching systems. As such, you often want to check the cache early, and save to it late. The third argument to attach() is a priority value. The higher this number, the earlier that listener will execute; the lower it is, the later it executes. The value defaults to 1, and values will trigger in the order registered within a given priority. To implement a caching system, our method will need to trigger an event at method start as well as at method end. At method start, we want an event that will trigger early; at method end, an event should trigger late. Here is the class in which we want caching: class SomeValueObject { // assume it composes an event manager public function get($id) { $params = compact('id'); $results = $this->getEventManager()->trigger('get.pre', $this, $params); // If an event stopped propagation, return the value if ($results->stopped()) { return $results->last(); } // do some work... $params['__RESULT__'] = $someComputedContent; $this->getEventManager()->trigger('get.post', $this, $params); } } Now, let's create a ListenerAggregateInterface implementation that can handle caching for us: use Zend\\Cache\\Cache; use Zend\\EventManager\\EventManagerInterface; use Zend\\EventManager\\ListenerAggregateInterface; use Zend\\EventManager\\ListenerAggregateTrait; use Zend\\EventManager\\EventInterface; class CacheListener implements ListenerAggregateInterface { use ListenerAggregateTrait; private $cache; public function __construct(Cache $cache) { $this->cache = $cache; } public function attach(EventManagerInterface $events) { $this->listeners[] = $events->attach('get.pre', [$this, 'load'], 100); $this->listeners[] = $events->attach('get.post', [$this, 'save'], -100); } public function load(EventInterface $e) { $id = get_class($e->getTarget()) . '-' . json_encode($e->getParams()); if (false !== ($content = $this->cache->load($id))) { $e->stopPropagation(true); return $content; } } public function save(EventInterface $e) { $params = $e->getParams(); $content = $params['__RESULT__']; unset($params['__RESULT__']); $id = get_class($e->getTarget()) . '-' . json_encode($params); $this->cache->save($content, $id); } } We can then attach the aggregate to an event manager instance. $value = new SomeValueObject(); $cacheListener = new CacheListener($cache); $cacheListener->attach($value->getEventManager()); Now, as we call get() , if we have a cached entry, it will be returned immediately; if not, a computed entry will be cached when we complete the method.","title":"Examples"},{"location":"examples/#examples","text":"","title":"Examples"},{"location":"examples/#modifying-arguments","text":"Occasionally it can be useful to allow listeners to modify the arguments they receive so that later listeners or the calling method will receive those changed values. As an example, you might want to pre-filter a date that you know will arrive as a string and convert it to a DateTime argument. To do this, you can pass your arguments to prepareArgs() , and pass this new object when triggering an event. You will then pull that value back into your method. use DateTime; class ValueObject { // assume a composed event manager function inject(array $values) { $argv = compact('values'); $argv = $this->getEventManager()->prepareArgs($argv); $this->getEventManager()->trigger(__FUNCTION__, $this, $argv); $date = isset($argv['values']['date']) ? $argv['values']['date'] : new DateTime('now'); // ... } } $v = new ValueObject(); $v->getEventManager()->attach('inject', function($e) { $values = $e->getParam('values'); if (! $values) { return; } $values['date'] = isset($values['date']) ? new DateTime($values['date']) : new DateTime('now'); $e->setParam('values', $values); }); $v->inject([ 'date' => '2011-08-10 15:30:29', ]);","title":"Modifying Arguments"},{"location":"examples/#short-circuiting","text":"One common use case for events is to trigger listeners until either one indicates no further processing should be done, or until a return value meets specific criteria. As an example, a request listener might be able to return a response object, and would signal to the target to stop event propagation. $listener = function($e) { // do some work // Stop propagation and return a response $e->stopPropagation(true); return $response; }; Alternately, the request handler could halt execution at the first listener that returns a response. class Foo implements DispatchableInterface { // assume composed event manager public function dispatch(Request $request, Response $response = null) { $argv = compact('request', 'response'); $results = $this->getEventManager()->triggerUntil(function($v) { return ($v instanceof Response); }, __FUNCTION__, $this, $argv); } } Typically, you may want to return the value that stopped execution, or use it some way. All trigger*() methods return a ResponseCollection instance; call its stopped() method to test if execution was stopped, and the last() method to retrieve the return value from the last executed listener: class Foo implements DispatchableInterface { // assume composed event manager public function dispatch(Request $request, Response $response = null) { $argv = compact('request', 'response'); $results = $this->getEventManager()->triggerUntil(function($v) { return ($v instanceof Response); }, __FUNCTION__, $this, $argv); // Test if execution was halted, and return last result: if ($results->stopped()) { return $results->last(); } // continue... } }","title":"Short Circuiting"},{"location":"examples/#assigning-priority-to-listeners","text":"One use case for the EventManager is for implementing caching systems. As such, you often want to check the cache early, and save to it late. The third argument to attach() is a priority value. The higher this number, the earlier that listener will execute; the lower it is, the later it executes. The value defaults to 1, and values will trigger in the order registered within a given priority. To implement a caching system, our method will need to trigger an event at method start as well as at method end. At method start, we want an event that will trigger early; at method end, an event should trigger late. Here is the class in which we want caching: class SomeValueObject { // assume it composes an event manager public function get($id) { $params = compact('id'); $results = $this->getEventManager()->trigger('get.pre', $this, $params); // If an event stopped propagation, return the value if ($results->stopped()) { return $results->last(); } // do some work... $params['__RESULT__'] = $someComputedContent; $this->getEventManager()->trigger('get.post', $this, $params); } } Now, let's create a ListenerAggregateInterface implementation that can handle caching for us: use Zend\\Cache\\Cache; use Zend\\EventManager\\EventManagerInterface; use Zend\\EventManager\\ListenerAggregateInterface; use Zend\\EventManager\\ListenerAggregateTrait; use Zend\\EventManager\\EventInterface; class CacheListener implements ListenerAggregateInterface { use ListenerAggregateTrait; private $cache; public function __construct(Cache $cache) { $this->cache = $cache; } public function attach(EventManagerInterface $events) { $this->listeners[] = $events->attach('get.pre', [$this, 'load'], 100); $this->listeners[] = $events->attach('get.post', [$this, 'save'], -100); } public function load(EventInterface $e) { $id = get_class($e->getTarget()) . '-' . json_encode($e->getParams()); if (false !== ($content = $this->cache->load($id))) { $e->stopPropagation(true); return $content; } } public function save(EventInterface $e) { $params = $e->getParams(); $content = $params['__RESULT__']; unset($params['__RESULT__']); $id = get_class($e->getTarget()) . '-' . json_encode($params); $this->cache->save($content, $id); } } We can then attach the aggregate to an event manager instance. $value = new SomeValueObject(); $cacheListener = new CacheListener($cache); $cacheListener->attach($value->getEventManager()); Now, as we call get() , if we have a cached entry, it will be returned immediately; if not, a computed entry will be cached when we complete the method.","title":"Assigning Priority to Listeners"},{"location":"intercepting-filters/","text":"Intercepting Filters Intercepting filters are a design pattern used for providing mechanisms to alter the workflow of an application. Implementing them provides a way to have a standard public interface, with the ability to attach arbitrary numbers of filters that will take the incoming arguments in order to alter the workflow. zend-eventmanager provides an intercepting filter implementation via Zend\\EventManager\\FilterChain . Preparation To use the FilterChain implementation, you will need to install zend-stdlib, if you have not already: $ composer require zendframework/zend-stdlib FilterChainInterface Zend\\EventManager\\FilterChain is a concrete implementation of Zend\\EventManager\\Filter\\FilterInterface , which defines a workflow for intercepting filters. This includes the following methods: interface FilterInterface { public function run($context, array $params = []); public function attach(callable $callback); public function detach(callable $callback); public function getFilters(); public function clearFilters(); public function getResponses(); } In many ways, it's very similar to the EventManagerInterface , but with a few key differences: A filter essentially defines a single event, which obviates the need for attaching to multiple events. As such, you pass the target and parameters only when \"triggering\" ( run() ) a filter. Instead of passing an EventInterface to each attached filter, a FilterInterface implementation will pass: The $context The $params A FilterIterator , to allow the listener to call on the next filter. FilterIterator When executing run() , a FilterInterface implementation is expected to provide the stack of attached filters to each listener. This stack will typically be a Zend\\EventManager\\Filter\\FilterIterator instance. FilterIterator extends Zend\\Stdlib\\FastPriorityQueue , and, as such, is iterable, and provides the method next() for advancing the queue. As such, a listener should decide if more processing is necessary, and, if so, call on $chain->next() , passing the same set of arguments. Filters A filter attached to a FilterChain instance can be any callable. However, these callables should expect the following arguments: function ($context, array $argv, FilterIterator $chain) A filter can therefore act on the provided $context , using the provided arguments. Part of that execution can also be deciding that other filters should be called. To do so, it will call $chain->next() , providing it the same arguments: function ($context, array $argv, FilterIterator $chain) { $message = isset($argv['message']) ? $argv['message'] : ''; $message = str_rot13($message); $filtered = $chain->next($context, ['message' => $message], $chain); return str_rot13($filtered); } You can choose to call $chain->next() at any point in the filter, allowing you to: pre-process arguments and/or alter the state of the $context . post-process results and/or alter the state of the $context based on the results. skip processing entirely if criteria is not met (e.g., missing arguments, invalid $context state). short-circuit the chain if no processing is necessary (e.g., a cache hit is detected). Execution When executing a filter chain, you will provide the $context , which is usually the object under observation, and arguments, which are typically the arguments passed to the method triggering the filter chain. As an example, consider the following filter-enabled class: use Zend\\EventManager\\FilterChain; class ObservedTarget { private $filters = []; public function attachFilter($method, callable $listener) { if (! method_exists($this, $method)) { throw new \\InvalidArgumentException('Invalid method'); } $this->getFilters($method)->attach($listener); } public function execute($message) { return $this->getFilters(__FUNCTION__) ->run($this, compact('message')); } private function getFilters($method) { if (! isset($this->filters[$method])) { $this->filters[$method] = new FilterChain(); } return $this->filters[$method]; } } Now, let's create an instance of the class, and attach some filters to it. $observed = new ObservedTarget(); $observed->attach(function ($context, array $args, FilterIterator $chain) { $args['message'] = isset($args['message']) ? strtoupper($args['message']) : ''; return $chain->next($context, $args, $chain); }); $observed->attach(function ($context, array $args, FilterIterator $chain) { return (isset($args['message']) ? str_rot13($args['message']) : ''); }); $observed->attach(function ($context, array $args, FilterIterator $chain) { return (isset($args['message']) ? strtolower($args['message']) : ''); }); Finally, we'll call the method, and see what results we get: $observed->execute('Hello, world!'); Since filters are run in the order in which they are attached, the following will occur: The first filter will transform our message into HELLO, WORLD! , and then call on the next filter. The second filter will apply a ROT13 transformation on the string and return it: !DLROW ,OLLEH . Because the second filter does not call $chain->next() , the third filter never executes. Notes We recommend using the construct run($this, compact(method argument names) when invoking a FilterChain . This makes the argument keys predictable inside filters. We also recommend putting the default logic for the method invoking the filter chain in a filter itself, and attaching it at invocation. This allows intercepting filters to replace the main logic, while still providing a default path. This might look like: // Assume that the class contains the `attachFilter()` implementation from above. class ObservedTarget { private $attached = []; public function execute($message) { if (! isset($this->attached[__FUNCTION__])) { $this->attachFilter(__FUNCTION__, $this->getExecuteFilter(); } return $this->getFilters(__FUNCTION__) ->run($this, compact('message')); } private function getExecuteFilter() { $this->attached['execute'] = true; return function ($context, array $args, FilterIterator $chain) { return $args['message']; }; } } Intercepting filters are a powerful way to introduce aspect-oriented programming paradigms into your code, as well as general-purpose mechanisms for introducing plugins.","title":"Intercepting Filters"},{"location":"intercepting-filters/#intercepting-filters","text":"Intercepting filters are a design pattern used for providing mechanisms to alter the workflow of an application. Implementing them provides a way to have a standard public interface, with the ability to attach arbitrary numbers of filters that will take the incoming arguments in order to alter the workflow. zend-eventmanager provides an intercepting filter implementation via Zend\\EventManager\\FilterChain .","title":"Intercepting Filters"},{"location":"intercepting-filters/#preparation","text":"To use the FilterChain implementation, you will need to install zend-stdlib, if you have not already: $ composer require zendframework/zend-stdlib","title":"Preparation"},{"location":"intercepting-filters/#filterchaininterface","text":"Zend\\EventManager\\FilterChain is a concrete implementation of Zend\\EventManager\\Filter\\FilterInterface , which defines a workflow for intercepting filters. This includes the following methods: interface FilterInterface { public function run($context, array $params = []); public function attach(callable $callback); public function detach(callable $callback); public function getFilters(); public function clearFilters(); public function getResponses(); } In many ways, it's very similar to the EventManagerInterface , but with a few key differences: A filter essentially defines a single event, which obviates the need for attaching to multiple events. As such, you pass the target and parameters only when \"triggering\" ( run() ) a filter. Instead of passing an EventInterface to each attached filter, a FilterInterface implementation will pass: The $context The $params A FilterIterator , to allow the listener to call on the next filter.","title":"FilterChainInterface"},{"location":"intercepting-filters/#filteriterator","text":"When executing run() , a FilterInterface implementation is expected to provide the stack of attached filters to each listener. This stack will typically be a Zend\\EventManager\\Filter\\FilterIterator instance. FilterIterator extends Zend\\Stdlib\\FastPriorityQueue , and, as such, is iterable, and provides the method next() for advancing the queue. As such, a listener should decide if more processing is necessary, and, if so, call on $chain->next() , passing the same set of arguments.","title":"FilterIterator"},{"location":"intercepting-filters/#filters","text":"A filter attached to a FilterChain instance can be any callable. However, these callables should expect the following arguments: function ($context, array $argv, FilterIterator $chain) A filter can therefore act on the provided $context , using the provided arguments. Part of that execution can also be deciding that other filters should be called. To do so, it will call $chain->next() , providing it the same arguments: function ($context, array $argv, FilterIterator $chain) { $message = isset($argv['message']) ? $argv['message'] : ''; $message = str_rot13($message); $filtered = $chain->next($context, ['message' => $message], $chain); return str_rot13($filtered); } You can choose to call $chain->next() at any point in the filter, allowing you to: pre-process arguments and/or alter the state of the $context . post-process results and/or alter the state of the $context based on the results. skip processing entirely if criteria is not met (e.g., missing arguments, invalid $context state). short-circuit the chain if no processing is necessary (e.g., a cache hit is detected).","title":"Filters"},{"location":"intercepting-filters/#execution","text":"When executing a filter chain, you will provide the $context , which is usually the object under observation, and arguments, which are typically the arguments passed to the method triggering the filter chain. As an example, consider the following filter-enabled class: use Zend\\EventManager\\FilterChain; class ObservedTarget { private $filters = []; public function attachFilter($method, callable $listener) { if (! method_exists($this, $method)) { throw new \\InvalidArgumentException('Invalid method'); } $this->getFilters($method)->attach($listener); } public function execute($message) { return $this->getFilters(__FUNCTION__) ->run($this, compact('message')); } private function getFilters($method) { if (! isset($this->filters[$method])) { $this->filters[$method] = new FilterChain(); } return $this->filters[$method]; } } Now, let's create an instance of the class, and attach some filters to it. $observed = new ObservedTarget(); $observed->attach(function ($context, array $args, FilterIterator $chain) { $args['message'] = isset($args['message']) ? strtoupper($args['message']) : ''; return $chain->next($context, $args, $chain); }); $observed->attach(function ($context, array $args, FilterIterator $chain) { return (isset($args['message']) ? str_rot13($args['message']) : ''); }); $observed->attach(function ($context, array $args, FilterIterator $chain) { return (isset($args['message']) ? strtolower($args['message']) : ''); }); Finally, we'll call the method, and see what results we get: $observed->execute('Hello, world!'); Since filters are run in the order in which they are attached, the following will occur: The first filter will transform our message into HELLO, WORLD! , and then call on the next filter. The second filter will apply a ROT13 transformation on the string and return it: !DLROW ,OLLEH . Because the second filter does not call $chain->next() , the third filter never executes.","title":"Execution"},{"location":"intercepting-filters/#notes","text":"We recommend using the construct run($this, compact(method argument names) when invoking a FilterChain . This makes the argument keys predictable inside filters. We also recommend putting the default logic for the method invoking the filter chain in a filter itself, and attaching it at invocation. This allows intercepting filters to replace the main logic, while still providing a default path. This might look like: // Assume that the class contains the `attachFilter()` implementation from above. class ObservedTarget { private $attached = []; public function execute($message) { if (! isset($this->attached[__FUNCTION__])) { $this->attachFilter(__FUNCTION__, $this->getExecuteFilter(); } return $this->getFilters(__FUNCTION__) ->run($this, compact('message')); } private function getExecuteFilter() { $this->attached['execute'] = true; return function ($context, array $args, FilterIterator $chain) { return $args['message']; }; } } Intercepting filters are a powerful way to introduce aspect-oriented programming paradigms into your code, as well as general-purpose mechanisms for introducing plugins.","title":"Notes"},{"location":"intro/","text":"The EventManager: Overview zend-eventmanager is a component designed for the following use cases: Implementing simple subject/observer patterns. Implementing Aspect-Oriented designs. Implementing event-driven architectures. The basic architecture allows you to attach and detach listeners to named events, both on a per-instance basis as well as via shared collections; trigger events; and interrupt execution of listeners.","title":"Intro"},{"location":"intro/#the-eventmanager-overview","text":"zend-eventmanager is a component designed for the following use cases: Implementing simple subject/observer patterns. Implementing Aspect-Oriented designs. Implementing event-driven architectures. The basic architecture allows you to attach and detach listeners to named events, both on a per-instance basis as well as via shared collections; trigger events; and interrupt execution of listeners.","title":"The EventManager: Overview"},{"location":"quick-start/","text":"Quick Start Typically, you will compose an EventManager instance in a class. use Zend\\EventManager\\EventManagerInterface; use Zend\\EventManager\\EventManager; use Zend\\EventManager\\EventManagerAwareInterface; class Foo implements EventManagerAwareInterface { protected $events; public function setEventManager(EventManagerInterface $events) { $events->setIdentifiers([ __CLASS__, get_called_class(), ]); $this->events = $events; return $this; } public function getEventManager() { if (null === $this->events) { $this->setEventManager(new EventManager()); } return $this->events; } } The above allows users to access the EventManager instance, or reset it with a new instance; if one does not exist, it will be lazily instantiated on-demand. The instance property $events is a convention for referring to the EventManager instance. An EventManager is really only interesting if it triggers some events. Basic triggering via the trigger() method takes three arguments: The event name , which is usually the current function/method name; The target , which is usually the current object instance; Event arguments , which are usually the arguments provided to the current function/method. class Foo { // ... assume events definition from above public function bar($baz, $bat = null) { $params = compact('baz', 'bat'); $this->getEventManager()->trigger(__FUNCTION__, $this, $params); } } In turn, triggering events is only interesting if something is listening for the event. Listeners attach to the EventManager , specifying a named event and the callback to notify. The callback receives an Event object, which has accessors for retrieving the event name, target, and parameters. Let's add a listener, and trigger the event. use Zend\\Log\\Factory as LogFactory; $log = LogFactory($someConfig); $foo = new Foo(); $foo->getEventManager()->attach('bar', function ($e) use ($log) { $event = $e->getName(); $target = get_class($e->getTarget()); $params = json_encode($e->getParams()); $log->info(sprintf( '%s called on %s, using params %s', $event, $target, $params )); }); // The following method call: $foo->bar('baz', 'bat'); // Results in the log message reading: // bar called on Foo, using params {\"baz\" : \"baz\", \"bat\" : \"bat\"}\" Note that the second argument to attach() is any valid PHP callable; an anonymous function is shown in the example in order to keep the example self-contained. However, you could also utilize a valid function name, a functor, a string referencing a static method, or an array callback with a named static method or instance method. Again, any PHP callable is valid. Sometimes you may want to specify listeners without yet having an object instance of the class composing an EventManager . Zend Framework enables this through the concept of a SharedEventManager . Simply put, you can inject individual EventManager instances with a well-known SharedEventManager , and the EventManager instance will query it for additional listeners. Listeners attach to a SharedEventManager in roughly the same way they do to normal event managers; the call to attach is identical to the EventManager , but expects an additional parameter at the beginning: a named instance. Remember the example of composing an EventManager , how we passed it an array containing __CLASS__ and get_called_class() ? Those values are then used to identify the event manager instance, and pull listeners registered with one of those identifiers from the SharedEventManager . As an example, assuming we have a SharedEventManager instance that we know has been injected in our EventManager instances (for instance, via dependency injection), we could change the above example to attach via the shared collection: use Zend\\Log\\Factory as LogFactory; // Assume $sharedEvents is a Zend\\EventManager\\SharedEventManager instance $log = LogFactory($someConfig); $sharedEvents->attach('Foo', 'bar', function ($e) use ($log) { $event = $e->getName(); $target = get_class($e->getTarget()); $params = json_encode($e->getParams()); $log->info(sprintf( '%s called on %s, using params %s', $event, $target, $params )); }); // Later, instantiate Foo: $foo = new Foo(); $foo->setEventManager(new EventManager($sharedEvents, [])); // And we can still trigger the above event: $foo->bar('baz', 'bat'); // results in log message: // bar called on Foo, using params {\"baz\" : \"baz\", \"bat\" : \"bat\"}\" The EventManager also provides the ability to detach listeners, short-circuit execution of an event either from within a listener or by testing return values of listeners, test and loop through the results returned by listeners, prioritize listeners, and more. Many of these features are detailed in the examples.","title":"Quick Start"},{"location":"quick-start/#quick-start","text":"Typically, you will compose an EventManager instance in a class. use Zend\\EventManager\\EventManagerInterface; use Zend\\EventManager\\EventManager; use Zend\\EventManager\\EventManagerAwareInterface; class Foo implements EventManagerAwareInterface { protected $events; public function setEventManager(EventManagerInterface $events) { $events->setIdentifiers([ __CLASS__, get_called_class(), ]); $this->events = $events; return $this; } public function getEventManager() { if (null === $this->events) { $this->setEventManager(new EventManager()); } return $this->events; } } The above allows users to access the EventManager instance, or reset it with a new instance; if one does not exist, it will be lazily instantiated on-demand. The instance property $events is a convention for referring to the EventManager instance. An EventManager is really only interesting if it triggers some events. Basic triggering via the trigger() method takes three arguments: The event name , which is usually the current function/method name; The target , which is usually the current object instance; Event arguments , which are usually the arguments provided to the current function/method. class Foo { // ... assume events definition from above public function bar($baz, $bat = null) { $params = compact('baz', 'bat'); $this->getEventManager()->trigger(__FUNCTION__, $this, $params); } } In turn, triggering events is only interesting if something is listening for the event. Listeners attach to the EventManager , specifying a named event and the callback to notify. The callback receives an Event object, which has accessors for retrieving the event name, target, and parameters. Let's add a listener, and trigger the event. use Zend\\Log\\Factory as LogFactory; $log = LogFactory($someConfig); $foo = new Foo(); $foo->getEventManager()->attach('bar', function ($e) use ($log) { $event = $e->getName(); $target = get_class($e->getTarget()); $params = json_encode($e->getParams()); $log->info(sprintf( '%s called on %s, using params %s', $event, $target, $params )); }); // The following method call: $foo->bar('baz', 'bat'); // Results in the log message reading: // bar called on Foo, using params {\"baz\" : \"baz\", \"bat\" : \"bat\"}\" Note that the second argument to attach() is any valid PHP callable; an anonymous function is shown in the example in order to keep the example self-contained. However, you could also utilize a valid function name, a functor, a string referencing a static method, or an array callback with a named static method or instance method. Again, any PHP callable is valid. Sometimes you may want to specify listeners without yet having an object instance of the class composing an EventManager . Zend Framework enables this through the concept of a SharedEventManager . Simply put, you can inject individual EventManager instances with a well-known SharedEventManager , and the EventManager instance will query it for additional listeners. Listeners attach to a SharedEventManager in roughly the same way they do to normal event managers; the call to attach is identical to the EventManager , but expects an additional parameter at the beginning: a named instance. Remember the example of composing an EventManager , how we passed it an array containing __CLASS__ and get_called_class() ? Those values are then used to identify the event manager instance, and pull listeners registered with one of those identifiers from the SharedEventManager . As an example, assuming we have a SharedEventManager instance that we know has been injected in our EventManager instances (for instance, via dependency injection), we could change the above example to attach via the shared collection: use Zend\\Log\\Factory as LogFactory; // Assume $sharedEvents is a Zend\\EventManager\\SharedEventManager instance $log = LogFactory($someConfig); $sharedEvents->attach('Foo', 'bar', function ($e) use ($log) { $event = $e->getName(); $target = get_class($e->getTarget()); $params = json_encode($e->getParams()); $log->info(sprintf( '%s called on %s, using params %s', $event, $target, $params )); }); // Later, instantiate Foo: $foo = new Foo(); $foo->setEventManager(new EventManager($sharedEvents, [])); // And we can still trigger the above event: $foo->bar('baz', 'bat'); // results in log message: // bar called on Foo, using params {\"baz\" : \"baz\", \"bat\" : \"bat\"}\" The EventManager also provides the ability to detach listeners, short-circuit execution of an event either from within a listener or by testing return values of listeners, test and loop through the results returned by listeners, prioritize listeners, and more. Many of these features are detailed in the examples.","title":"Quick Start"},{"location":"tutorial/","text":"Tutorial This tutorial explores the various features of zend-eventmanager. Terminology An Event is a named action. A Listener is any PHP callback that reacts to an event . An EventManager aggregates listeners for one or more named events, and triggers events. Typically, an event will be modeled as an object, containing metadata surrounding when and how it was triggered, including the event name, what object triggered the event (the \"target\"), and what parameters were provided. Events are named , which allows a single listener to branch logic based on the event. Getting started The minimal things necessary to start using events are: An EventManager instance One or more listeners on one or more events A call to trigger() an event The simplest example looks something like this: use Zend\\EventManager\\EventManager; $events = new EventManager(); $events->attach('do', function ($e) { $event = $e->getName(); $params = $e->getParams(); printf( 'Handled event \"%s\", with parameters %s', $event, json_encode($params) ); }); $params = ['foo' => 'bar', 'baz' => 'bat']; $events->trigger('do', null, $params); The above will result in the following: Handled event \"do\", with parameters {\"foo\":\"bar\",\"baz\":\"bat\"} Note Throughout this tutorial, we use closures as listeners. However, any valid PHP callback can be attached as a listeners: PHP function names, static class methods, object instance methods, functors, or closures. We use closures within this post simply for illustration and simplicity. If you were paying attention to the example, you will have noted the null argument. Why is it there? Typically, you will compose an EventManager within a class, to allow triggering actions within methods. The middle argument to trigger() is the \"target\", and in the case described, would be the current object instance. This gives event listeners access to the calling object, which can often be useful. use Zend\\EventManager\\EventManager; use Zend\\EventManager\\EventManagerAwareInterface; use Zend\\EventManager\\EventManagerInterface; class Example implements EventManagerAwareInterface { protected $events; public function setEventManager(EventManagerInterface $events) { $events->setIdentifiers([ __CLASS__, get_class($this) ]); $this->events = $events; } public function getEventManager() { if (! $this->events) { $this->setEventManager(new EventManager()); } return $this->events; } public function doIt($foo, $baz) { $params = compact('foo', 'baz'); $this->getEventManager()->trigger(__FUNCTION__, $this, $params); } } $example = new Example(); $example->getEventManager()->attach('doIt', function($e) { $event = $e->getName(); $target = get_class($e->getTarget()); // \"Example\" $params = $e->getParams(); printf( 'Handled event \"%s\" on target \"%s\", with parameters %s', $event, $target, json_encode($params) ); }); $example->doIt('bar', 'bat'); The above is basically the same as the first example. The main difference is that we're now using that middle argument in order to pass the target, the instance of Example , on to the listeners. Our listener is now retrieving that ( $e->getTarget() ), and doing something with it. If you're reading this critically, you should have a new question: What is the call to setIdentifiers() for? Shared managers One aspect that the EventManager implementation provides is an ability to compose a SharedEventManagerInterface implementation. Zend\\EventManager\\SharedEventManagerInterface describes an object that aggregates listeners for events attached to objects with specific identifiers . It does not trigger events itself. Instead, an EventManager instance that composes a SharedEventManager will query the SharedEventManager for listeners on identifiers it's interested in, and trigger those listeners as well. How does this work, exactly? Consider the following: use Zend\\EventManager\\SharedEventManager; $sharedEvents = new SharedEventManager(); $sharedEvents->attach('Example', 'do', function ($e) { $event = $e->getName(); $target = get_class($e->getTarget()); // \"Example\" $params = $e->getParams(); printf( 'Handled event \"%s\" on target \"%s\", with parameters %s', $event, $target, json_encode($params) ); }); This looks almost identical to the previous example; the key difference is that there is an additional argument at the start of the list, Example . This code is basically saying, \"Listen to the 'do' event of the 'Example' target, and, when notified, execute this callback.\" This is where the setIdentifiers() method of EventManager comes into play. The method allows passing an array of strings, defining the names of the context or targets the given instance will be interested in. So, getting back to our example, let's assume that the above shared listener is registered, and also that the Example class is defined as above. (Note that as of version 3, setSharedManager() is removed from EventManager ; the SharedEventManager instance must instead be injected via the constructor.) We can then execute the following: $example = new Example(); // Prior to version 3: $example->getEventManager()->setSharedManager($sharedEvents); // As of version 3: $example->setEventManager(new EventManager($sharedEvents)); // Both versions: $example->doIt('bar', 'bat'); and expect the following output: Handled event \"do\" on target \"Example\", with parameters {\"foo\":\"bar\",\"baz\":\"bat\"} Now, let's say we extended Example as follows: class SubExample extends Example { } One interesting aspect of our setEventManager() method is that we defined it to listen both on __CLASS__ and get_class($this) . This means that calling do() on our SubExample class would also trigger the shared listener! It also means that, if desired, we could attach to specifically SubExample , and listeners attached to only the Example target would not be triggered. Finally, the names used as contexts or targets need not be class names; they can be some name that only has meaning in your application if desired. As an example, you could have a set of classes that respond to \"log\" or \"cache\" \u2014 and listeners on these would be notified by any of them. Note We recommend using class names, interface names, and/or abstract class names for identifiers. This makes determining what events are available easier, as well as finding which listeners might be attaching to those events. Interfaces make a particularly good use case, as they allow attaching to a group of related classes a single operation. Wildcards So far, with both a normal EventManager instance and with the SharedEventManager instance, we've seen the usage of singular strings representing the event and target names to which we want to attach. What if you want to attach a listener to multiple events or targets? One answer is to attach to the event manager using the wildcard event, * . Consider the following examples: $events->attach( '*', // all events $listener ); // All targets via wildcard $sharedEvents->attach( '*', // all targets 'doSomething', // named event $listener ); // Mix and match: all events on a single named target: $sharedEvents->attach( 'Foo', // target '*', // all events $listener ); // Mix and match: all events on all targets: $sharedEvents->attach( '*', // all targets '*', // all events $listener ); The ability to specify wildcard targets and/or events when attaching can slim down your code immensely. Listener aggregates Another approach to listening to multiple events is via a concept of listener aggregates, represented by Zend\\EventManager\\ListenerAggregateInterface . Via this approach, a single class can listen to multiple events, attaching one or more instance methods as listeners. This interface defines two methods, attach(EventManagerInterface $events) and detach(EventManagerInterface $events) . Basically, you pass an EventManager instance to one and/or the other, and then it's up to the implementing class to determine what to do. As an example: use Zend\\EventManager\\EventInterface; use Zend\\EventManager\\EventManagerInterface; use Zend\\EventManager\\ListenerAggregateInterface; use Zend\\Log\\Logger; class LogEvents implements ListenerAggregateInterface { private $listeners = []; private $log; public function __construct(Logger $log) { $this->log = $log; } public function attach(EventManagerInterface $events) { $this->listeners[] = $events->attach('do', [$this, 'log']); $this->listeners[] = $events->attach('doSomethingElse', [$this, 'log']); } public function detach(EventManagerInterface $events) { foreach ($this->listeners as $index => $listener) { $events->detach($listener); unset($this->listeners[$index]); } } public function log(EventInterface $e) { $event = $e->getName(); $params = $e->getParams(); $this->log->info(sprintf('%s: %s', $event, json_encode($params))); } } Note The trait Zend\\EventManager\\ListenerAggregateTrait can be composed to help implement ListenerAggregateInterface ; it defines the $listeners property, and the detach() logic as demonstrated above. You can attach this by passing the event manager to the aggregate's attach() method: $logListener = new LogEvents($logger); $logListener->attach($events); Any events the aggregate attaches to will then be notified when triggered. Why bother? For a couple of reasons: Aggregates allow you to have stateful listeners. The above example demonstrates this via the composition of the logger; another example would be tracking configuration options. Aggregates allow grouping related listeners in a single class, and attaching them at once. Introspecting results Sometimes you'll want to know what your listeners returned. One thing to remember is that you may have multiple listeners on the same event; the interface for results must be consistent regardless of the number of listeners. The EventManager implementation by default returns a Zend\\EventManager\\ResponseCollection instance. This class extends PHP's SplStack , allowing you to loop through responses in reverse order (since the last one executed is likely the one you're most interested in). It also implements the following methods: first() will retrieve the first result received last() will retrieve the last result received contains($value) allows you to test all values to see if a given one was received, and returns simply a boolean true if found, and false if not. Typically, you should not worry about the return values from events, as the object triggering the event shouldn't really have much insight into what listeners are attached. However, sometimes you may want to short-circuit execution if interesting results are obtained. Short-circuiting listener execution You may want to short-circuit execution if a particular result is obtained, or if a listener determines that something is wrong, or that it can return something quicker than the target. As examples, one rationale for adding an EventManager is as a caching mechanism. You can trigger one event early in the method, returning if a cache is found, and trigger another event late in the method, seeding the cache. The EventManager component offers two ways to handle this. The first is to use the methods triggerUntil() or triggerEventUntil() . These accept a callback as their first argument; if that callback returns a boolean true value, execution is halted. As an example: public function someExpensiveCall($criteria1, $criteria2) { $params = compact('criteria1', 'criteria2'); $results = $this->getEventManager()->triggerUntil( function ($r) { return ($r instanceof SomeResultClass); }, __FUNCTION__, $this, $params ); if ($results->stopped()) { return $results->last(); } // ... do some work ... } With this paradigm, we know that the likely reason of execution halting is due to the last result meeting the test callback criteria; as such, we simply return that last result. The other way to halt execution is within a listener, acting on the Event object it receives. In this case, the listener calls stopPropagation(true) , and the EventManager will then return without notifying any additional listeners. $events->attach('do', function ($e) { $e->stopPropagation(); return new SomeResultClass(); }); This, of course, raises some ambiguity when using the trigger paradigm, as you can no longer be certain that the last result meets the criteria it's searching on. As such, we recommend that you standardize on one approach or the other. Keeping it in order On occasion, you may be concerned about the order in which listeners execute. As an example, you may want to do any logging early, to ensure that if short-circuiting occurs, you've logged; or if implementing a cache, you may want to return early if a cache hit is found, and execute late when saving to a cache. Each of EventManager::attach() and SharedEventManager::attach() accept one additional argument, a priority . By default, if this is omitted, listeners get a priority of 1, and are executed in the order in which they are attached. However, if you provide a priority value, you can influence order of execution. Higher priority values execute earlier . Lower (negative) priority values execute later . To borrow an example from earlier: $priority = 100; $events->attach('Example', 'do', function($e) { $event = $e->getName(); $target = get_class($e->getTarget()); // \"Example\" $params = $e->getParams(); printf( 'Handled event \"%s\" on target \"%s\", with parameters %s', $event, $target, json_encode($params) ); }, $priority); This would execute with high priority, meaning it would execute early. If we changed $priority to -100 , it would execute with low priority, executing late. While you can't necessarily know all the listeners attached, chances are you can make adequate guesses when necessary in order to set appropriate priority values. We advise avoiding setting a priority value unless absolutely necessary. Custom event objects Hopefully some of you have been wondering, \"where and when is the Event object created\"? In all of the examples above, it's created based on the arguments passed to trigger() \u2014 the event name, target, and parameters. Sometimes, however, you may want greater control over the object. As an example, one thing that looks like a code smell is when you have code like this: $routeMatch = $e->getParam('route-match', false); if ( !$routeMatch) { // Oh noes! we cannot do our work! whatever shall we do?!?!?! } The problems with this are several. First, relying on string keys is going to very quickly run into problems \u2014 typos when setting or retrieving the argument can lead to hard to debug situations. Second, we now have a documentation issue; how do we document expected arguments? how do we document what we're shoving into the event? Third, as a side effect, we can't use IDE or editor hinting support \u2014 string keys give these tools nothing to work with. Similarly, consider how you might represent a computational result of a method when triggering an event. As an example: // in the method: $params['__RESULT'] = $computedResult; $events->trigger(__FUNCTION__ . '.post', $this, $params); // in the listener: $result = $e->getParam('__RESULT__'); if (! $result) { // Oh noes! we cannot do our work! whatever shall we do?!?!?! } Sure, that key may be unique, but it suffers from a lot of the same issues. So, the solution is to create custom events. As an example, we have a custom MvcEvent in zend-mvc. This event composes the application instance, the router, the route match object, request and response objects, the view model, and also a result. We end up with code like this in our listeners: $response = $e->getResponse(); $result = $e->getResult(); if (is_string($result)) { $content = $view->render('layout.phtml', ['content' => $result]); $response->setContent($content); } But how do we use this custom event? Simple: the method triggerEvent() . $event = new CustomEvent(); $event->setName('foo'); $event->setTarget($this); $event->setSomeKey($value); // Injected with event name and target: $events->triggerEvent($event); // Use triggerEventUntil() for criteria-based short-circuiting: $results = $events->triggerEventUntil($callback, $event); This is a really powerful technique for domain-specific event systems, and definitely worth experimenting with. Putting it together: Implementing a simple caching system In previous sections, I indicated that short-circuiting is a way to potentially implement a caching solution. Let's create a full example. First, let's define a method that could use caching. You'll note that in most of the examples, I've used __FUNCTION__ as the event name; this is a good practice, as it makes it simple to create a macro for triggering events, as well as helps to keep event names unique (as they're usually within the context of the triggering class). However, in the case of a caching example, this would lead to identical events being triggered. As such, I recommend postfixing the event name with semantic names: \"do.pre\", \"do.post\", \"do.error\", etc. I'll use that convention in this example. Additionally, you'll notice that the $params I pass to the event is usually the list of parameters passed to the method. This is because those are often not stored in the object, and also to ensure the listeners have the exact same context as the calling method. But it raises an interesting problem in this example: what name do we give the result of the method? One standard that has emerged is the use of __RESULT__ , as double-underscored variables are typically reserved for the system. Here's what the method will look like: public function someExpensiveCall($criteria1, $criteria2) { $params = compact('criteria1', 'criteria2'); $results = $this->getEventManager()->triggerUntil( function ($r) { return ($r instanceof SomeResultClass); }, __FUNCTION__ . '.pre', $this, $params ); if ($results->stopped()) { return $results->last(); } // ... do some work ... $params['__RESULT__'] = $calculatedResult; $this->events()->trigger(__FUNCTION__ . '.post', $this, $params); return $calculatedResult; } Now, to provide some caching listeners. We'll need to attach to each of the someExpensiveCall.pre and someExpensiveCall.post methods. In the former; case, if a cache hit is detected, we return it, and move on. In the latter, we store the value in the cache. We'll assume $cache is defined, and follows the paradigms of Zend\\Cache . We'll want to return early if a hit is detected, and execute late when saving a cache (in case the result is modified by another listener). As such, we'll set the someExpensiveCall.pre listener to execute with priority 100 , and the someExpensiveCall.post listener to execute with priority -100 . $events->attach('someExpensiveCall.pre', function($e) use ($cache) { $params = $e->getParams(); $key = md5(json_encode($params)); $hit = $cache->load($key); return $hit; }, 100); $events->attach('someExpensiveCall.post', function($e) use ($cache) { $params = $e->getParams(); $result = $params['__RESULT__']; unset($params['__RESULT__']); $key = md5(json_encode($params)); $cache->save($result, $key); }, -100); Note The above could have been done within a ListenerAggregate , which would have allowed keeping the $cache instance as a stateful property, instead of importing it into closures. Another approach would be to move the body of the method to a listener as well, which would allow using the priority system in order to implement caching. That would look like this: public function setEventManager(EventManagerInterface $events) { $this->events = $events; $events->setIdentifiers(array(__CLASS__, get_class($this))); $events->attach('someExpensiveCall', [$this, 'doSomeExpensiveCall']); } public function someExpensiveCall($criteria1, $criteria2) { $params = compact('criteria1', 'criteria2'); $results = $this->getEventManager()->triggerUntil( function ($r) { return ($r instanceof SomeResultClass); }, __FUNCTION__, $this, $params ); return $results->last(); } public function doSomeExpensiveCall($e) { // ... do some work ... $e->setParam('__RESULT__', $calculatedResult); return $calculatedResult; } The listeners would then attach to the someExpensiveCall event, with the cache lookup listener listening at high priority, and the cache storage listener listening at low (negative) priority. Sure, we could probably simply add caching to the object itself \u2014 but this approach allows the same handlers to be attached to multiple events, or to attach multiple listeners to the same events (e.g. an argument validator, a logger and a cache manager). The point is that if you design your object with events in mind, you can easily make it more flexible and extensible, without requiring developers to actually extend it \u2014 they can simply attach listeners. Conclusion The EventManager is a powerful component. It drives the workflow of zend-mvc, and is used in countless components to provide hook points for developers to manipulate the workflow. It can be put to any number of uses inside your own code, and is an important part of your Zend Framework toolbox.","title":"Tutorial"},{"location":"tutorial/#tutorial","text":"This tutorial explores the various features of zend-eventmanager.","title":"Tutorial"},{"location":"tutorial/#terminology","text":"An Event is a named action. A Listener is any PHP callback that reacts to an event . An EventManager aggregates listeners for one or more named events, and triggers events. Typically, an event will be modeled as an object, containing metadata surrounding when and how it was triggered, including the event name, what object triggered the event (the \"target\"), and what parameters were provided. Events are named , which allows a single listener to branch logic based on the event.","title":"Terminology"},{"location":"tutorial/#getting-started","text":"The minimal things necessary to start using events are: An EventManager instance One or more listeners on one or more events A call to trigger() an event The simplest example looks something like this: use Zend\\EventManager\\EventManager; $events = new EventManager(); $events->attach('do', function ($e) { $event = $e->getName(); $params = $e->getParams(); printf( 'Handled event \"%s\", with parameters %s', $event, json_encode($params) ); }); $params = ['foo' => 'bar', 'baz' => 'bat']; $events->trigger('do', null, $params); The above will result in the following: Handled event \"do\", with parameters {\"foo\":\"bar\",\"baz\":\"bat\"}","title":"Getting started"},{"location":"tutorial/#note","text":"Throughout this tutorial, we use closures as listeners. However, any valid PHP callback can be attached as a listeners: PHP function names, static class methods, object instance methods, functors, or closures. We use closures within this post simply for illustration and simplicity. If you were paying attention to the example, you will have noted the null argument. Why is it there? Typically, you will compose an EventManager within a class, to allow triggering actions within methods. The middle argument to trigger() is the \"target\", and in the case described, would be the current object instance. This gives event listeners access to the calling object, which can often be useful. use Zend\\EventManager\\EventManager; use Zend\\EventManager\\EventManagerAwareInterface; use Zend\\EventManager\\EventManagerInterface; class Example implements EventManagerAwareInterface { protected $events; public function setEventManager(EventManagerInterface $events) { $events->setIdentifiers([ __CLASS__, get_class($this) ]); $this->events = $events; } public function getEventManager() { if (! $this->events) { $this->setEventManager(new EventManager()); } return $this->events; } public function doIt($foo, $baz) { $params = compact('foo', 'baz'); $this->getEventManager()->trigger(__FUNCTION__, $this, $params); } } $example = new Example(); $example->getEventManager()->attach('doIt', function($e) { $event = $e->getName(); $target = get_class($e->getTarget()); // \"Example\" $params = $e->getParams(); printf( 'Handled event \"%s\" on target \"%s\", with parameters %s', $event, $target, json_encode($params) ); }); $example->doIt('bar', 'bat'); The above is basically the same as the first example. The main difference is that we're now using that middle argument in order to pass the target, the instance of Example , on to the listeners. Our listener is now retrieving that ( $e->getTarget() ), and doing something with it. If you're reading this critically, you should have a new question: What is the call to setIdentifiers() for?","title":"Note"},{"location":"tutorial/#shared-managers","text":"One aspect that the EventManager implementation provides is an ability to compose a SharedEventManagerInterface implementation. Zend\\EventManager\\SharedEventManagerInterface describes an object that aggregates listeners for events attached to objects with specific identifiers . It does not trigger events itself. Instead, an EventManager instance that composes a SharedEventManager will query the SharedEventManager for listeners on identifiers it's interested in, and trigger those listeners as well. How does this work, exactly? Consider the following: use Zend\\EventManager\\SharedEventManager; $sharedEvents = new SharedEventManager(); $sharedEvents->attach('Example', 'do', function ($e) { $event = $e->getName(); $target = get_class($e->getTarget()); // \"Example\" $params = $e->getParams(); printf( 'Handled event \"%s\" on target \"%s\", with parameters %s', $event, $target, json_encode($params) ); }); This looks almost identical to the previous example; the key difference is that there is an additional argument at the start of the list, Example . This code is basically saying, \"Listen to the 'do' event of the 'Example' target, and, when notified, execute this callback.\" This is where the setIdentifiers() method of EventManager comes into play. The method allows passing an array of strings, defining the names of the context or targets the given instance will be interested in. So, getting back to our example, let's assume that the above shared listener is registered, and also that the Example class is defined as above. (Note that as of version 3, setSharedManager() is removed from EventManager ; the SharedEventManager instance must instead be injected via the constructor.) We can then execute the following: $example = new Example(); // Prior to version 3: $example->getEventManager()->setSharedManager($sharedEvents); // As of version 3: $example->setEventManager(new EventManager($sharedEvents)); // Both versions: $example->doIt('bar', 'bat'); and expect the following output: Handled event \"do\" on target \"Example\", with parameters {\"foo\":\"bar\",\"baz\":\"bat\"} Now, let's say we extended Example as follows: class SubExample extends Example { } One interesting aspect of our setEventManager() method is that we defined it to listen both on __CLASS__ and get_class($this) . This means that calling do() on our SubExample class would also trigger the shared listener! It also means that, if desired, we could attach to specifically SubExample , and listeners attached to only the Example target would not be triggered. Finally, the names used as contexts or targets need not be class names; they can be some name that only has meaning in your application if desired. As an example, you could have a set of classes that respond to \"log\" or \"cache\" \u2014 and listeners on these would be notified by any of them.","title":"Shared managers"},{"location":"tutorial/#note_1","text":"We recommend using class names, interface names, and/or abstract class names for identifiers. This makes determining what events are available easier, as well as finding which listeners might be attaching to those events. Interfaces make a particularly good use case, as they allow attaching to a group of related classes a single operation.","title":"Note"},{"location":"tutorial/#wildcards","text":"So far, with both a normal EventManager instance and with the SharedEventManager instance, we've seen the usage of singular strings representing the event and target names to which we want to attach. What if you want to attach a listener to multiple events or targets? One answer is to attach to the event manager using the wildcard event, * . Consider the following examples: $events->attach( '*', // all events $listener ); // All targets via wildcard $sharedEvents->attach( '*', // all targets 'doSomething', // named event $listener ); // Mix and match: all events on a single named target: $sharedEvents->attach( 'Foo', // target '*', // all events $listener ); // Mix and match: all events on all targets: $sharedEvents->attach( '*', // all targets '*', // all events $listener ); The ability to specify wildcard targets and/or events when attaching can slim down your code immensely.","title":"Wildcards"},{"location":"tutorial/#listener-aggregates","text":"Another approach to listening to multiple events is via a concept of listener aggregates, represented by Zend\\EventManager\\ListenerAggregateInterface . Via this approach, a single class can listen to multiple events, attaching one or more instance methods as listeners. This interface defines two methods, attach(EventManagerInterface $events) and detach(EventManagerInterface $events) . Basically, you pass an EventManager instance to one and/or the other, and then it's up to the implementing class to determine what to do. As an example: use Zend\\EventManager\\EventInterface; use Zend\\EventManager\\EventManagerInterface; use Zend\\EventManager\\ListenerAggregateInterface; use Zend\\Log\\Logger; class LogEvents implements ListenerAggregateInterface { private $listeners = []; private $log; public function __construct(Logger $log) { $this->log = $log; } public function attach(EventManagerInterface $events) { $this->listeners[] = $events->attach('do', [$this, 'log']); $this->listeners[] = $events->attach('doSomethingElse', [$this, 'log']); } public function detach(EventManagerInterface $events) { foreach ($this->listeners as $index => $listener) { $events->detach($listener); unset($this->listeners[$index]); } } public function log(EventInterface $e) { $event = $e->getName(); $params = $e->getParams(); $this->log->info(sprintf('%s: %s', $event, json_encode($params))); } }","title":"Listener aggregates"},{"location":"tutorial/#note_2","text":"The trait Zend\\EventManager\\ListenerAggregateTrait can be composed to help implement ListenerAggregateInterface ; it defines the $listeners property, and the detach() logic as demonstrated above. You can attach this by passing the event manager to the aggregate's attach() method: $logListener = new LogEvents($logger); $logListener->attach($events); Any events the aggregate attaches to will then be notified when triggered. Why bother? For a couple of reasons: Aggregates allow you to have stateful listeners. The above example demonstrates this via the composition of the logger; another example would be tracking configuration options. Aggregates allow grouping related listeners in a single class, and attaching them at once.","title":"Note"},{"location":"tutorial/#introspecting-results","text":"Sometimes you'll want to know what your listeners returned. One thing to remember is that you may have multiple listeners on the same event; the interface for results must be consistent regardless of the number of listeners. The EventManager implementation by default returns a Zend\\EventManager\\ResponseCollection instance. This class extends PHP's SplStack , allowing you to loop through responses in reverse order (since the last one executed is likely the one you're most interested in). It also implements the following methods: first() will retrieve the first result received last() will retrieve the last result received contains($value) allows you to test all values to see if a given one was received, and returns simply a boolean true if found, and false if not. Typically, you should not worry about the return values from events, as the object triggering the event shouldn't really have much insight into what listeners are attached. However, sometimes you may want to short-circuit execution if interesting results are obtained.","title":"Introspecting results"},{"location":"tutorial/#short-circuiting-listener-execution","text":"You may want to short-circuit execution if a particular result is obtained, or if a listener determines that something is wrong, or that it can return something quicker than the target. As examples, one rationale for adding an EventManager is as a caching mechanism. You can trigger one event early in the method, returning if a cache is found, and trigger another event late in the method, seeding the cache. The EventManager component offers two ways to handle this. The first is to use the methods triggerUntil() or triggerEventUntil() . These accept a callback as their first argument; if that callback returns a boolean true value, execution is halted. As an example: public function someExpensiveCall($criteria1, $criteria2) { $params = compact('criteria1', 'criteria2'); $results = $this->getEventManager()->triggerUntil( function ($r) { return ($r instanceof SomeResultClass); }, __FUNCTION__, $this, $params ); if ($results->stopped()) { return $results->last(); } // ... do some work ... } With this paradigm, we know that the likely reason of execution halting is due to the last result meeting the test callback criteria; as such, we simply return that last result. The other way to halt execution is within a listener, acting on the Event object it receives. In this case, the listener calls stopPropagation(true) , and the EventManager will then return without notifying any additional listeners. $events->attach('do', function ($e) { $e->stopPropagation(); return new SomeResultClass(); }); This, of course, raises some ambiguity when using the trigger paradigm, as you can no longer be certain that the last result meets the criteria it's searching on. As such, we recommend that you standardize on one approach or the other.","title":"Short-circuiting listener execution"},{"location":"tutorial/#keeping-it-in-order","text":"On occasion, you may be concerned about the order in which listeners execute. As an example, you may want to do any logging early, to ensure that if short-circuiting occurs, you've logged; or if implementing a cache, you may want to return early if a cache hit is found, and execute late when saving to a cache. Each of EventManager::attach() and SharedEventManager::attach() accept one additional argument, a priority . By default, if this is omitted, listeners get a priority of 1, and are executed in the order in which they are attached. However, if you provide a priority value, you can influence order of execution. Higher priority values execute earlier . Lower (negative) priority values execute later . To borrow an example from earlier: $priority = 100; $events->attach('Example', 'do', function($e) { $event = $e->getName(); $target = get_class($e->getTarget()); // \"Example\" $params = $e->getParams(); printf( 'Handled event \"%s\" on target \"%s\", with parameters %s', $event, $target, json_encode($params) ); }, $priority); This would execute with high priority, meaning it would execute early. If we changed $priority to -100 , it would execute with low priority, executing late. While you can't necessarily know all the listeners attached, chances are you can make adequate guesses when necessary in order to set appropriate priority values. We advise avoiding setting a priority value unless absolutely necessary.","title":"Keeping it in order"},{"location":"tutorial/#custom-event-objects","text":"Hopefully some of you have been wondering, \"where and when is the Event object created\"? In all of the examples above, it's created based on the arguments passed to trigger() \u2014 the event name, target, and parameters. Sometimes, however, you may want greater control over the object. As an example, one thing that looks like a code smell is when you have code like this: $routeMatch = $e->getParam('route-match', false); if ( !$routeMatch) { // Oh noes! we cannot do our work! whatever shall we do?!?!?! } The problems with this are several. First, relying on string keys is going to very quickly run into problems \u2014 typos when setting or retrieving the argument can lead to hard to debug situations. Second, we now have a documentation issue; how do we document expected arguments? how do we document what we're shoving into the event? Third, as a side effect, we can't use IDE or editor hinting support \u2014 string keys give these tools nothing to work with. Similarly, consider how you might represent a computational result of a method when triggering an event. As an example: // in the method: $params['__RESULT'] = $computedResult; $events->trigger(__FUNCTION__ . '.post', $this, $params); // in the listener: $result = $e->getParam('__RESULT__'); if (! $result) { // Oh noes! we cannot do our work! whatever shall we do?!?!?! } Sure, that key may be unique, but it suffers from a lot of the same issues. So, the solution is to create custom events. As an example, we have a custom MvcEvent in zend-mvc. This event composes the application instance, the router, the route match object, request and response objects, the view model, and also a result. We end up with code like this in our listeners: $response = $e->getResponse(); $result = $e->getResult(); if (is_string($result)) { $content = $view->render('layout.phtml', ['content' => $result]); $response->setContent($content); } But how do we use this custom event? Simple: the method triggerEvent() . $event = new CustomEvent(); $event->setName('foo'); $event->setTarget($this); $event->setSomeKey($value); // Injected with event name and target: $events->triggerEvent($event); // Use triggerEventUntil() for criteria-based short-circuiting: $results = $events->triggerEventUntil($callback, $event); This is a really powerful technique for domain-specific event systems, and definitely worth experimenting with.","title":"Custom event objects"},{"location":"tutorial/#putting-it-together-implementing-a-simple-caching-system","text":"In previous sections, I indicated that short-circuiting is a way to potentially implement a caching solution. Let's create a full example. First, let's define a method that could use caching. You'll note that in most of the examples, I've used __FUNCTION__ as the event name; this is a good practice, as it makes it simple to create a macro for triggering events, as well as helps to keep event names unique (as they're usually within the context of the triggering class). However, in the case of a caching example, this would lead to identical events being triggered. As such, I recommend postfixing the event name with semantic names: \"do.pre\", \"do.post\", \"do.error\", etc. I'll use that convention in this example. Additionally, you'll notice that the $params I pass to the event is usually the list of parameters passed to the method. This is because those are often not stored in the object, and also to ensure the listeners have the exact same context as the calling method. But it raises an interesting problem in this example: what name do we give the result of the method? One standard that has emerged is the use of __RESULT__ , as double-underscored variables are typically reserved for the system. Here's what the method will look like: public function someExpensiveCall($criteria1, $criteria2) { $params = compact('criteria1', 'criteria2'); $results = $this->getEventManager()->triggerUntil( function ($r) { return ($r instanceof SomeResultClass); }, __FUNCTION__ . '.pre', $this, $params ); if ($results->stopped()) { return $results->last(); } // ... do some work ... $params['__RESULT__'] = $calculatedResult; $this->events()->trigger(__FUNCTION__ . '.post', $this, $params); return $calculatedResult; } Now, to provide some caching listeners. We'll need to attach to each of the someExpensiveCall.pre and someExpensiveCall.post methods. In the former; case, if a cache hit is detected, we return it, and move on. In the latter, we store the value in the cache. We'll assume $cache is defined, and follows the paradigms of Zend\\Cache . We'll want to return early if a hit is detected, and execute late when saving a cache (in case the result is modified by another listener). As such, we'll set the someExpensiveCall.pre listener to execute with priority 100 , and the someExpensiveCall.post listener to execute with priority -100 . $events->attach('someExpensiveCall.pre', function($e) use ($cache) { $params = $e->getParams(); $key = md5(json_encode($params)); $hit = $cache->load($key); return $hit; }, 100); $events->attach('someExpensiveCall.post', function($e) use ($cache) { $params = $e->getParams(); $result = $params['__RESULT__']; unset($params['__RESULT__']); $key = md5(json_encode($params)); $cache->save($result, $key); }, -100);","title":"Putting it together: Implementing a simple caching system"},{"location":"tutorial/#note_3","text":"The above could have been done within a ListenerAggregate , which would have allowed keeping the $cache instance as a stateful property, instead of importing it into closures. Another approach would be to move the body of the method to a listener as well, which would allow using the priority system in order to implement caching. That would look like this: public function setEventManager(EventManagerInterface $events) { $this->events = $events; $events->setIdentifiers(array(__CLASS__, get_class($this))); $events->attach('someExpensiveCall', [$this, 'doSomeExpensiveCall']); } public function someExpensiveCall($criteria1, $criteria2) { $params = compact('criteria1', 'criteria2'); $results = $this->getEventManager()->triggerUntil( function ($r) { return ($r instanceof SomeResultClass); }, __FUNCTION__, $this, $params ); return $results->last(); } public function doSomeExpensiveCall($e) { // ... do some work ... $e->setParam('__RESULT__', $calculatedResult); return $calculatedResult; } The listeners would then attach to the someExpensiveCall event, with the cache lookup listener listening at high priority, and the cache storage listener listening at low (negative) priority. Sure, we could probably simply add caching to the object itself \u2014 but this approach allows the same handlers to be attached to multiple events, or to attach multiple listeners to the same events (e.g. an argument validator, a logger and a cache manager). The point is that if you design your object with events in mind, you can easily make it more flexible and extensible, without requiring developers to actually extend it \u2014 they can simply attach listeners.","title":"Note"},{"location":"tutorial/#conclusion","text":"The EventManager is a powerful component. It drives the workflow of zend-mvc, and is used in countless components to provide hook points for developers to manipulate the workflow. It can be put to any number of uses inside your own code, and is an important part of your Zend Framework toolbox.","title":"Conclusion"},{"location":"wildcard-listeners/","text":"Wildcard Listeners Sometimes you'll want to attach the same listener to all events of a given instance \u2014 or potentially, with a shared event collection, all contexts. Attaching using the wildcard To attach to all events on a given EventManager instance, you can use the wildcard event, * : $events = new EventManager(); $events->attach('*', $listener); Note that if you specify a priority, that priority will be used for this listener for any event triggered. What the above specifies is that any event triggered by the event manager instance will result in notification of this particular listener. Attaching using the wildcard via a SharedEventManager Using the SharedEventManager , you can indicate that you want to attach to all events of a given identifier, a single named event across all identifiers, or all events on all identifiers. $sharedEvents = new SharedEventManager(); // Attach to all events on the context \"foo\" $sharedEvents->attach('foo', '*', $listener); // Attach to the \"foo\" event of any context: $sharedEvents->attach('*', 'foo', $listener); // Attach to all events on all contexts: $sharedEvents->attach('*', '*', $listener); Note that if you specify a priority, that priority will be used for all events specified.","title":"Wildcard Listeners"},{"location":"wildcard-listeners/#wildcard-listeners","text":"Sometimes you'll want to attach the same listener to all events of a given instance \u2014 or potentially, with a shared event collection, all contexts.","title":"Wildcard Listeners"},{"location":"wildcard-listeners/#attaching-using-the-wildcard","text":"To attach to all events on a given EventManager instance, you can use the wildcard event, * : $events = new EventManager(); $events->attach('*', $listener); Note that if you specify a priority, that priority will be used for this listener for any event triggered. What the above specifies is that any event triggered by the event manager instance will result in notification of this particular listener.","title":"Attaching using the wildcard"},{"location":"wildcard-listeners/#attaching-using-the-wildcard-via-a-sharedeventmanager","text":"Using the SharedEventManager , you can indicate that you want to attach to all events of a given identifier, a single named event across all identifiers, or all events on all identifiers. $sharedEvents = new SharedEventManager(); // Attach to all events on the context \"foo\" $sharedEvents->attach('foo', '*', $listener); // Attach to the \"foo\" event of any context: $sharedEvents->attach('*', 'foo', $listener); // Attach to all events on all contexts: $sharedEvents->attach('*', '*', $listener); Note that if you specify a priority, that priority will be used for all events specified.","title":"Attaching using the wildcard via a SharedEventManager"},{"location":"lazy-listeners/intro/","text":"Lazy Listeners Lazy listeners are a new feature in version 3.0, provided to reduce the performance overhead of fetching listeners and/or aggregates from a Dependency Injection Container until they are actually triggered. The feature consists of three classes: Zend\\EventManager\\LazyListener , which provides basic capabilities for wrapping the retrieval of a listener from a container and invoking it. Zend\\EventManager\\LazyEventListener , which extends LazyListener but adds awareness of the event and optionally priority to use when attaching the listener. These are primarily used and created by: Zend\\EventManager\\LazyListenerAggregate , which can take a list of LazyEventListeners and/or their definitions, and be used as an aggregate listener for attaching the lazy listeners to an event manager. Preparation In order to use the lazy listeners feature, you will need to install container-interop, if you haven't already: $ composer require container-interop/container-interop","title":"Intro"},{"location":"lazy-listeners/intro/#lazy-listeners","text":"Lazy listeners are a new feature in version 3.0, provided to reduce the performance overhead of fetching listeners and/or aggregates from a Dependency Injection Container until they are actually triggered. The feature consists of three classes: Zend\\EventManager\\LazyListener , which provides basic capabilities for wrapping the retrieval of a listener from a container and invoking it. Zend\\EventManager\\LazyEventListener , which extends LazyListener but adds awareness of the event and optionally priority to use when attaching the listener. These are primarily used and created by: Zend\\EventManager\\LazyListenerAggregate , which can take a list of LazyEventListeners and/or their definitions, and be used as an aggregate listener for attaching the lazy listeners to an event manager.","title":"Lazy Listeners"},{"location":"lazy-listeners/intro/#preparation","text":"In order to use the lazy listeners feature, you will need to install container-interop, if you haven't already: $ composer require container-interop/container-interop","title":"Preparation"},{"location":"lazy-listeners/lazy-event-listener/","text":"LazyEventListener Zend\\EventManager\\LazyEventListener extends from LazyListener , but requires supplying the event name to which to attach, and optionally the priority, in the definition supplied at construction. This allows it to be a standalone instance that a listener aggregate can then query and use to attach to an event manager instance. Usage As noted in the introduction, the LazyEventListener is aware of two additional keys in the definition supplied at instantiation: event is the name of the event to which the lazy listener should attach. priority can optionally be provided to indicate the priority at which the lazy listener should attach. As an example, let's assume: We have a listener registered in our container with the service name My\\Application\\Listener , and we want to use the method onDispatch when listening; further, we want to attach it to the event dispatch , at priority 100. Additionally, we'll assume that we have a container-interop instance in the variable $container and an event manager in the variable $events . You could create the lazy event listener as follows: use My\\Application\\Listener; use Zend\\EventManager\\LazyEventListener; $listener = new LazyEventListener([ 'listener' => Listener::class, 'method' => 'onDispatch', 'event' => 'dispatch', 'priority' => 100, ], $container); Methods LazyEventListener exposes two methods: getEvent() returns the event name used. getPriority($default = 1) returns either the priority passed at instantiation, or, if none was provided, the default passed when invoking the method. Aggregates The LazyEventListener features are primarily geared towards registering lazy listeners in aggregates. To that end, you will rarely instantiate or interact with them directly; instead, you'll leave that to the LazyListenerAggregate .","title":"LazyEventListener"},{"location":"lazy-listeners/lazy-event-listener/#lazyeventlistener","text":"Zend\\EventManager\\LazyEventListener extends from LazyListener , but requires supplying the event name to which to attach, and optionally the priority, in the definition supplied at construction. This allows it to be a standalone instance that a listener aggregate can then query and use to attach to an event manager instance.","title":"LazyEventListener"},{"location":"lazy-listeners/lazy-event-listener/#usage","text":"As noted in the introduction, the LazyEventListener is aware of two additional keys in the definition supplied at instantiation: event is the name of the event to which the lazy listener should attach. priority can optionally be provided to indicate the priority at which the lazy listener should attach. As an example, let's assume: We have a listener registered in our container with the service name My\\Application\\Listener , and we want to use the method onDispatch when listening; further, we want to attach it to the event dispatch , at priority 100. Additionally, we'll assume that we have a container-interop instance in the variable $container and an event manager in the variable $events . You could create the lazy event listener as follows: use My\\Application\\Listener; use Zend\\EventManager\\LazyEventListener; $listener = new LazyEventListener([ 'listener' => Listener::class, 'method' => 'onDispatch', 'event' => 'dispatch', 'priority' => 100, ], $container);","title":"Usage"},{"location":"lazy-listeners/lazy-event-listener/#methods","text":"LazyEventListener exposes two methods: getEvent() returns the event name used. getPriority($default = 1) returns either the priority passed at instantiation, or, if none was provided, the default passed when invoking the method.","title":"Methods"},{"location":"lazy-listeners/lazy-event-listener/#aggregates","text":"The LazyEventListener features are primarily geared towards registering lazy listeners in aggregates. To that end, you will rarely instantiate or interact with them directly; instead, you'll leave that to the LazyListenerAggregate .","title":"Aggregates"},{"location":"lazy-listeners/lazy-listener-aggregate/","text":"LazyListenerAggregate Zend\\EventManager\\LazyListenerAggregate exists to facilitate attaching a number of listeners as lazy listeners. Usage Similar to a LazyListener or LazyEventListener , the LazyListenerAggregate accepts a definition (or, rather, set of definitions) a container-interop instance, and optionall an $env array to its constructor. Unlike either, however, the definition provided is an array of definitions to use to create LazyEventListener instances; you may also intersperse actual LazyEventListener instances if desired. As an example, let's assume we have two listeners, My\\Application\\RouteListener and My\\Application\\DispatchListener ; the first will use its onRoute() method to listen to the route event at priority 100, the second its onDispatch() method to listen to the dispatch event at priority -100. use My\\Application\\DispatchListener; use My\\Application\\RouteListener; use Zend\\EventManager\\LazyListenerAggregate; $definitions = [ [ 'listener' => RouteListener::class, 'method' => 'onRoute', 'event' => 'route', 'priority' => 100, ], [ 'listener' => DispatchListener::class, 'method' => 'onDispatch', 'event' => 'dispatch', 'priority' => -100, ], ]; $aggregate = new LazyListenerAggregate( $definitions, $container ); $aggregate->attach($events); Internally, the LazyListenerAggregate will create LazyEventListener instances, and during its attach() phase use them to attach to the event manager using the event and priority they compose. Below is a functionally identical example, mixing in a concrete LazyEventListener instance for one listener: use My\\Application\\DispatchListener; use My\\Application\\RouteListener; use Zend\\EventManager\\LazyEventListener; use Zend\\EventManager\\LazyListenerAggregate; $dispatchListener = new LazyEventListener([ 'listener' => DispatchListener::class, 'method' => 'onDispatch', 'event' => 'dispatch', 'priority' => -100, ], $container); $definitions = [ [ 'listener' => RouteListener::class, 'method' => 'onRoute', 'event' => 'route', 'priority' => 100, ], $dispatchListener, ]; $aggregate = new LazyListenerAggregate( $definitions, $container ); $aggregate->attach($events); Recommendations We recommend using LazyListenerAggregate when you have listeners you will be pulling from a Dependency Injection Container, but which may not execute on every request; this will help minimize the number of objects pulled from the DIC. As pulling instances from a DIC is often an expensive operation, this can be a healthy performance optimization.","title":"LazyListenerAggregate"},{"location":"lazy-listeners/lazy-listener-aggregate/#lazylisteneraggregate","text":"Zend\\EventManager\\LazyListenerAggregate exists to facilitate attaching a number of listeners as lazy listeners.","title":"LazyListenerAggregate"},{"location":"lazy-listeners/lazy-listener-aggregate/#usage","text":"Similar to a LazyListener or LazyEventListener , the LazyListenerAggregate accepts a definition (or, rather, set of definitions) a container-interop instance, and optionall an $env array to its constructor. Unlike either, however, the definition provided is an array of definitions to use to create LazyEventListener instances; you may also intersperse actual LazyEventListener instances if desired. As an example, let's assume we have two listeners, My\\Application\\RouteListener and My\\Application\\DispatchListener ; the first will use its onRoute() method to listen to the route event at priority 100, the second its onDispatch() method to listen to the dispatch event at priority -100. use My\\Application\\DispatchListener; use My\\Application\\RouteListener; use Zend\\EventManager\\LazyListenerAggregate; $definitions = [ [ 'listener' => RouteListener::class, 'method' => 'onRoute', 'event' => 'route', 'priority' => 100, ], [ 'listener' => DispatchListener::class, 'method' => 'onDispatch', 'event' => 'dispatch', 'priority' => -100, ], ]; $aggregate = new LazyListenerAggregate( $definitions, $container ); $aggregate->attach($events); Internally, the LazyListenerAggregate will create LazyEventListener instances, and during its attach() phase use them to attach to the event manager using the event and priority they compose. Below is a functionally identical example, mixing in a concrete LazyEventListener instance for one listener: use My\\Application\\DispatchListener; use My\\Application\\RouteListener; use Zend\\EventManager\\LazyEventListener; use Zend\\EventManager\\LazyListenerAggregate; $dispatchListener = new LazyEventListener([ 'listener' => DispatchListener::class, 'method' => 'onDispatch', 'event' => 'dispatch', 'priority' => -100, ], $container); $definitions = [ [ 'listener' => RouteListener::class, 'method' => 'onRoute', 'event' => 'route', 'priority' => 100, ], $dispatchListener, ]; $aggregate = new LazyListenerAggregate( $definitions, $container ); $aggregate->attach($events);","title":"Usage"},{"location":"lazy-listeners/lazy-listener-aggregate/#recommendations","text":"We recommend using LazyListenerAggregate when you have listeners you will be pulling from a Dependency Injection Container, but which may not execute on every request; this will help minimize the number of objects pulled from the DIC. As pulling instances from a DIC is often an expensive operation, this can be a healthy performance optimization.","title":"Recommendations"},{"location":"lazy-listeners/lazy-listener/","text":"LazyListener Zend\\EventManager\\LazyListener provides a callable wrapper around fetching a listener from a container and invoking it. Usage To create a LazyListener instance, you must pass to its constructor: a definition of the listener; this is an array defining: a listener key, with the name of the listener service to pull from the container. a method key, with the name of the method to invoke on the listener instance. a container ; this is a container-interop , such as provided by zend-servicemanager , Aura.Di , etc. optionally an $env array; this is a set of options or other configuration to use when creating the listener instance. Since not all containers support passing additional options at creation, we recommend omitting the $env argument when creating portable applications. As an example, let's assume: We have a listener registered in our container with the service name My\\Application\\Listener . The specific listener method is onDispatch . I have a container-interop instance in the variable $container and an event manager in the variable $events . I might then create and attach my lazy listener as follows: use My\\Application\\Listener; use Zend\\EventManager\\LazyListener; $events->attach('foo', new LazyListener([ 'listener' => Listener::class, 'method' => 'onDispatch', ], $container)); LazyListener implements the method __invoke() , allowing you to attach it directly as a callable listener! Internally, it will do essentially the following: $listener = $container->get($this->listener); $method = $this->method; return $listener->{$method}($event);","title":"LazyListener"},{"location":"lazy-listeners/lazy-listener/#lazylistener","text":"Zend\\EventManager\\LazyListener provides a callable wrapper around fetching a listener from a container and invoking it.","title":"LazyListener"},{"location":"lazy-listeners/lazy-listener/#usage","text":"To create a LazyListener instance, you must pass to its constructor: a definition of the listener; this is an array defining: a listener key, with the name of the listener service to pull from the container. a method key, with the name of the method to invoke on the listener instance. a container ; this is a container-interop , such as provided by zend-servicemanager , Aura.Di , etc. optionally an $env array; this is a set of options or other configuration to use when creating the listener instance. Since not all containers support passing additional options at creation, we recommend omitting the $env argument when creating portable applications. As an example, let's assume: We have a listener registered in our container with the service name My\\Application\\Listener . The specific listener method is onDispatch . I have a container-interop instance in the variable $container and an event manager in the variable $events . I might then create and attach my lazy listener as follows: use My\\Application\\Listener; use Zend\\EventManager\\LazyListener; $events->attach('foo', new LazyListener([ 'listener' => Listener::class, 'method' => 'onDispatch', ], $container)); LazyListener implements the method __invoke() , allowing you to attach it directly as a callable listener! Internally, it will do essentially the following: $listener = $container->get($this->listener); $method = $this->method; return $listener->{$method}($event);","title":"Usage"},{"location":"migration/changed/","text":"Changed Functionality The following methods had changes in signatures. EventManager::__construct() In version 2, the signature of __construct() was: __construct($identifiers = null) where $identifiers could be a string, array of strings, or Traversable of strings. Version 3 requires that the shared event manager be injected at instantiation, instead of via a setter. This also enforces the idea that identifiers have no semantic meaning without a shared event manager composed. As such, the constructor now has two arguments, with the first being the shared event manager: __construct(SharedEventManagerInterface $sharedEvents, array $identifiers = []) Finally, because we changed the signature of setIdentifiers() and addIdentifiers() to only accept arrays (see more below), we changed the $identifiers argument to only allow arrays. EventManagerInterface::trigger() and triggerUntil() In version 2, the signatures of trigger() and triggerUntil() are: trigger($event, $target = null, $argv = [], $callback = null); triggerUntil($event, $target = null, $argv = [], $callback = null); The methods allow overloading essentially every argument: $event could be the event name, array or traversable of event names, or an EventInterface instance. $target could be a callable representing the short-circuit callback, an EventInterface instance, or a value representing the target of the event. $argv could be a callable representing the short-circuit callback, an EventInterface instance, or an array/ ArrayAccess /object instance representing the event arguments. $callback could be either null or a callable. The amount of overloading leads to: 4 x 3 x 3 = 36 permutations of arguments, leading to confusion about how to call the method. Dozens of lines used to validate and marshal arguments. In version 3, we changed the methods to have the following signatures: trigger($event, $target = null, $argv = []); triggerUntil(callable $callback, $event, $target = null, $argv = []); with the following definitions: $event is a string event name. $target is a value representing the target of the event. $argv is an array/ ArrayAccess /object instance representing the event arguments. $callback is a callable to use to introspect listener return values in order to determine whether or not to short-circuit. In other words, each argument has exactly one possible type. $callback was moved to the start of the triggerUntil() method as it's required for that usage, and ensures the argument order stays predictable for the remaining arguments. In order to accommodate other styles of usage, we added the following methods: triggerUntil(callable $callback, $event, $target = null, $argv = []); triggerEvent(EventInterface $event); triggerEventUntil(callable $callback, EventInterface $event); These allow the other primary use cases for trigger() in v2, but with discrete signatures. Starting in version 2.6.0, you can use these three additional methods, as the EventManager instance defines them starting in that version. We recommend evaluating your code to see which of the four possible call styles you are using, and that you adapt your code to use one of the 4 discrete methods. The following signatures, however, are no longer supported, and will need to be updated as illustrated: // Event instance as second argument: $events->trigger('foo', $event); // Resolve by setting the event name prior to trigger: $event->setName('foo'); $events->triggerEvent($event); // Event instance as third argument: $events->trigger('foo', $this, $event); // Resolve by setting the event name and target prior to trigger: $event->setName('foo'); $event->setTarget($this); $events->triggerEvent($event); If you are using a callback to short-circuit, use one of the *Until() methods, passing the callback as the first argument: // Standard trigger: $events->trigger('foo', $this, ['bar' => 'baz'], $criteria); // becomes: $events->triggerUntil($criteria, 'foo', $this, ['bar' => 'baz']); // Triggering with an event: $events->trigger($event, $criteria); // becomes: $events->triggerEventUntil($criteria, $event); EventManagerInterface::attach() and detach() In version 2, attach() and detach() had the following signatures: attach($event, $callback = null, $priority = null); detach($listener); with the following argument definitions: $event could be either a string event name, or an instance of ListenerAggregateInterface . $callback could be a callable, an instance of Zend\\Stdlib\\CallbackHandler , or an integer priority (if $event was an aggregate). $priority could be null or an integer. $listener could be either a Zend\\Stdlib\\CallbackHandler (as that was how listeners were stored internally in that version), or an instance of ListenerAggregateInterface . Much like we did for the trigger*() methods, we simplified the signatures: attach($event, callable $listener, $priority = 1); detach(callable $listener, $event = null); Where: $event is always a string event name (except when not passed to detach() . $listener is always the callable listener. $priority is always an integer. detach() adds the $event argument as the event argument for a couple of reasons. First, in version 2, the event was composed in the CallbackHandler , which meant it didn't need to be sent separately; since the event managers now store the listeners directly, you must pass the $event if you want to detach from a specific event. This leads to the second reason: by omitting the argument, you can now remove a listener from all events to which it is attached \u2014 a new capability for version 3. In order to migrate to version 3, you will need to make a few changes to your application. First, if you are attaching or detaching aggregate listeners using attach() and detach() , you should change such calls to instead pass the event manager to the relevant ListenerAggregateInterface method, as detailed in the removed functionality documentation. These methods have existed in all released versions, giving perfect forwards compatibility. Second, if you are manually creating CallbackHandler instances to attach to an event manager, stop doing so, and attach the callable listener itself instead. This, too, is completely forwards compatible. If you are passing CallbackHandler instances to detach() , you will need to make the following change after updating to version 3: // This code: $events->detach($callbackHandler); // Will become: $events->detach($callbackHandler->getCallback()); In most cases, the callback handler you are storing is likely the result of calling attach() in the first place. Since attach() no longer creates a CallbackHandler instance, it instead simply returns the listener back to the caller. If you were storing this to pass later to detach() (such as in a listener aggregate), you will not need to make any changes when migrating. EventManagerInterface::setEventClass() and setEventPrototype() setEventClass() was renamed to setEventPrototype() and given a new signature; see the setEventClass() removal information for details. EventManagerInterface::setIdentifiers() and addIdentifiers() EventManagerInterface::setIdentifiers() and addIdentifiers() had a minor signature change. In version 2, the $identifiers argument allowed any of string , array , or Traversable . In version 3, only arrays are allowed. Additionally, neither implements a fluent interface any longer; you cannot chain their calls. SharedEventManagerInterface::getListeners() Zend\\EventManager\\SharedEventManagerInterface::getListeners() has changed. The previous signature was: getListeners($id, $event = null): false|Zend\\Stdlib\\PriorityQueue Version 3 has the following signature: getListeners(array $identifiers, $eventName) : array The changes are: The first argument now expects an array of identifiers. This is so an event manager instance can retrieve shared listeners for all identifiers it defines at once. The second argument is now required . Since the event manager always knows the event at the time it calls the method, it makes sense to require the argument for all calls. It also reduces complexity in the implementation. The method now always returns an array. The array will be of the structure [ 'priority' => callable[] ] . SharedEventManagerInterface::attach() The v2 signature of attach() was: attach($id, $event, $callback, $priority = 1) : CallbackHandler|CallbackHandler[] where: $id could be a string identifier, or an array or Traversable of identifiers. $event was a string event name. $callback could be either a callable listener, or a CallbackHandler instance. $priority was an integer. The v3 signature becomes: attach($identifier, $eventName, callable $listener, $priority = 1) : void where: $identifier must be a string only . $eventName must be a string name. $listener must be a callable only . $priority is an integer. Migration concerns are thus: If you are passing arrays of identifiers to which to attach, you must now do so in a loop or using a construct such as array_walk : foreach ($identifiers as $id) { $sharedEvents->attach($id, $event, $listener); } array_walk($identifiers, function ($id) use ($listener) { $this->sharedEvents->attach($id, 'foo', $listener); }); If you are passing CallbackHandler arguments, pass the callable listener instead. If you were relying on being returned the CallbackHandler , you may now simply cache the $listener argument. SharedEventManagerInterface::detach() The v2 signature of detach() was: detach($id, CallbackHandler $listener) : bool where: $id was a string identifier $listener was a CallbackHandler instance the method returned a boolean indicating whether or not it removed anything. The v3 signature becomes: detach(callable $listener, $identifier = null, $eventName = null) : void where: $listener is the callable listener you wish to remove $identifier , if provided, is a specific identifier from which you want to remove the $listener . $eventName , if provided, is a specific event on the specified $id from which to remove the $listener the method no longer returns a value. When not specifying an identifier, the method contract indicates it should remove the listener from any identifier; similarly, in the absence of an event argument, it should remove the listener from any event on the identifier(s). This allows for mass removal! As the signatures differ, you will need to update any code calling detach() after upgrading to v3. At the minimum, you will need to swap the $identifier and $listener arguments, and pass the callable listener instead of a CallbackHandler instance. We also recommend auditing your code to determine if you want to be more or less specific when detaching the listener. ListenerAggregateInterface::attach() Zend\\EventManager\\ListenerAggregateInterface::attach() was updated to add an optional argument, $priority = 1 . This codifies how the EventManager was already implemented. Since PHP allows adding optional arguments to concrete implementations of abstract methods, you can forward-proof your existing ListenerAggregateInterface implementations by adding the argument. As an example, if you define your method like this: public function attach(EventManagerInterface $events) Simply change it to this: public function attach(EventManagerInterface $events, $priority = 1) You do not need to do anything with the $priority argument, though we recommend passing it as a default value if you are not specifying a priority for any listeners you attach. FilterInterface::attach() and detach() Zend\\EventManager\\Filter\\FilterInterface::attach() and detach() have changed signatures. The originals were: attach($callback) : CallbackHandler detach(CallbackHandler $callback) : bool where $callback for attach() could be a callable or a CallbackHandler . The new signatures are: attach(callable $callback) : void detach(callable $filter) : bool Typical usage in v2 was to capture the return value of attach() and pass it to detach() , as attach() would create a CallbackHandler for you to later pass to detach() . Since we can now pass the original callable argument to detach() now, you can cache that value instead. FilterIterator Zend\\EventManager\\Filter\\FilterIterator now defines/overrides the insert() method in order to validate the incoming value and ensure it is callable, raising an exception when it is not. This simplifies logic in FilterChain , as it no longer needs to check if a filter is callable at runtime. The main migration change at this time is to know that an InvalidArgumentException will now be thrown when adding filters to a filter chain, vs at runtime. ResponseCollection::setStopped() Zend\\EventManager\\ResponseCollection::setStopped() no longer implements a fluent interface.","title":"Changed Functionality"},{"location":"migration/changed/#changed-functionality","text":"The following methods had changes in signatures.","title":"Changed Functionality"},{"location":"migration/changed/#eventmanager__construct","text":"In version 2, the signature of __construct() was: __construct($identifiers = null) where $identifiers could be a string, array of strings, or Traversable of strings. Version 3 requires that the shared event manager be injected at instantiation, instead of via a setter. This also enforces the idea that identifiers have no semantic meaning without a shared event manager composed. As such, the constructor now has two arguments, with the first being the shared event manager: __construct(SharedEventManagerInterface $sharedEvents, array $identifiers = []) Finally, because we changed the signature of setIdentifiers() and addIdentifiers() to only accept arrays (see more below), we changed the $identifiers argument to only allow arrays.","title":"EventManager::__construct()"},{"location":"migration/changed/#eventmanagerinterfacetrigger-and-triggeruntil","text":"In version 2, the signatures of trigger() and triggerUntil() are: trigger($event, $target = null, $argv = [], $callback = null); triggerUntil($event, $target = null, $argv = [], $callback = null); The methods allow overloading essentially every argument: $event could be the event name, array or traversable of event names, or an EventInterface instance. $target could be a callable representing the short-circuit callback, an EventInterface instance, or a value representing the target of the event. $argv could be a callable representing the short-circuit callback, an EventInterface instance, or an array/ ArrayAccess /object instance representing the event arguments. $callback could be either null or a callable. The amount of overloading leads to: 4 x 3 x 3 = 36 permutations of arguments, leading to confusion about how to call the method. Dozens of lines used to validate and marshal arguments. In version 3, we changed the methods to have the following signatures: trigger($event, $target = null, $argv = []); triggerUntil(callable $callback, $event, $target = null, $argv = []); with the following definitions: $event is a string event name. $target is a value representing the target of the event. $argv is an array/ ArrayAccess /object instance representing the event arguments. $callback is a callable to use to introspect listener return values in order to determine whether or not to short-circuit. In other words, each argument has exactly one possible type. $callback was moved to the start of the triggerUntil() method as it's required for that usage, and ensures the argument order stays predictable for the remaining arguments. In order to accommodate other styles of usage, we added the following methods: triggerUntil(callable $callback, $event, $target = null, $argv = []); triggerEvent(EventInterface $event); triggerEventUntil(callable $callback, EventInterface $event); These allow the other primary use cases for trigger() in v2, but with discrete signatures. Starting in version 2.6.0, you can use these three additional methods, as the EventManager instance defines them starting in that version. We recommend evaluating your code to see which of the four possible call styles you are using, and that you adapt your code to use one of the 4 discrete methods. The following signatures, however, are no longer supported, and will need to be updated as illustrated: // Event instance as second argument: $events->trigger('foo', $event); // Resolve by setting the event name prior to trigger: $event->setName('foo'); $events->triggerEvent($event); // Event instance as third argument: $events->trigger('foo', $this, $event); // Resolve by setting the event name and target prior to trigger: $event->setName('foo'); $event->setTarget($this); $events->triggerEvent($event); If you are using a callback to short-circuit, use one of the *Until() methods, passing the callback as the first argument: // Standard trigger: $events->trigger('foo', $this, ['bar' => 'baz'], $criteria); // becomes: $events->triggerUntil($criteria, 'foo', $this, ['bar' => 'baz']); // Triggering with an event: $events->trigger($event, $criteria); // becomes: $events->triggerEventUntil($criteria, $event);","title":"EventManagerInterface::trigger() and triggerUntil()"},{"location":"migration/changed/#eventmanagerinterfaceattach-and-detach","text":"In version 2, attach() and detach() had the following signatures: attach($event, $callback = null, $priority = null); detach($listener); with the following argument definitions: $event could be either a string event name, or an instance of ListenerAggregateInterface . $callback could be a callable, an instance of Zend\\Stdlib\\CallbackHandler , or an integer priority (if $event was an aggregate). $priority could be null or an integer. $listener could be either a Zend\\Stdlib\\CallbackHandler (as that was how listeners were stored internally in that version), or an instance of ListenerAggregateInterface . Much like we did for the trigger*() methods, we simplified the signatures: attach($event, callable $listener, $priority = 1); detach(callable $listener, $event = null); Where: $event is always a string event name (except when not passed to detach() . $listener is always the callable listener. $priority is always an integer. detach() adds the $event argument as the event argument for a couple of reasons. First, in version 2, the event was composed in the CallbackHandler , which meant it didn't need to be sent separately; since the event managers now store the listeners directly, you must pass the $event if you want to detach from a specific event. This leads to the second reason: by omitting the argument, you can now remove a listener from all events to which it is attached \u2014 a new capability for version 3. In order to migrate to version 3, you will need to make a few changes to your application. First, if you are attaching or detaching aggregate listeners using attach() and detach() , you should change such calls to instead pass the event manager to the relevant ListenerAggregateInterface method, as detailed in the removed functionality documentation. These methods have existed in all released versions, giving perfect forwards compatibility. Second, if you are manually creating CallbackHandler instances to attach to an event manager, stop doing so, and attach the callable listener itself instead. This, too, is completely forwards compatible. If you are passing CallbackHandler instances to detach() , you will need to make the following change after updating to version 3: // This code: $events->detach($callbackHandler); // Will become: $events->detach($callbackHandler->getCallback()); In most cases, the callback handler you are storing is likely the result of calling attach() in the first place. Since attach() no longer creates a CallbackHandler instance, it instead simply returns the listener back to the caller. If you were storing this to pass later to detach() (such as in a listener aggregate), you will not need to make any changes when migrating.","title":"EventManagerInterface::attach() and detach()"},{"location":"migration/changed/#eventmanagerinterfaceseteventclass-and-seteventprototype","text":"setEventClass() was renamed to setEventPrototype() and given a new signature; see the setEventClass() removal information for details.","title":"EventManagerInterface::setEventClass() and setEventPrototype()"},{"location":"migration/changed/#eventmanagerinterfacesetidentifiers-and-addidentifiers","text":"EventManagerInterface::setIdentifiers() and addIdentifiers() had a minor signature change. In version 2, the $identifiers argument allowed any of string , array , or Traversable . In version 3, only arrays are allowed. Additionally, neither implements a fluent interface any longer; you cannot chain their calls.","title":"EventManagerInterface::setIdentifiers() and addIdentifiers()"},{"location":"migration/changed/#sharedeventmanagerinterfacegetlisteners","text":"Zend\\EventManager\\SharedEventManagerInterface::getListeners() has changed. The previous signature was: getListeners($id, $event = null): false|Zend\\Stdlib\\PriorityQueue Version 3 has the following signature: getListeners(array $identifiers, $eventName) : array The changes are: The first argument now expects an array of identifiers. This is so an event manager instance can retrieve shared listeners for all identifiers it defines at once. The second argument is now required . Since the event manager always knows the event at the time it calls the method, it makes sense to require the argument for all calls. It also reduces complexity in the implementation. The method now always returns an array. The array will be of the structure [ 'priority' => callable[] ] .","title":"SharedEventManagerInterface::getListeners()"},{"location":"migration/changed/#sharedeventmanagerinterfaceattach","text":"The v2 signature of attach() was: attach($id, $event, $callback, $priority = 1) : CallbackHandler|CallbackHandler[] where: $id could be a string identifier, or an array or Traversable of identifiers. $event was a string event name. $callback could be either a callable listener, or a CallbackHandler instance. $priority was an integer. The v3 signature becomes: attach($identifier, $eventName, callable $listener, $priority = 1) : void where: $identifier must be a string only . $eventName must be a string name. $listener must be a callable only . $priority is an integer. Migration concerns are thus: If you are passing arrays of identifiers to which to attach, you must now do so in a loop or using a construct such as array_walk : foreach ($identifiers as $id) { $sharedEvents->attach($id, $event, $listener); } array_walk($identifiers, function ($id) use ($listener) { $this->sharedEvents->attach($id, 'foo', $listener); }); If you are passing CallbackHandler arguments, pass the callable listener instead. If you were relying on being returned the CallbackHandler , you may now simply cache the $listener argument.","title":"SharedEventManagerInterface::attach()"},{"location":"migration/changed/#sharedeventmanagerinterfacedetach","text":"The v2 signature of detach() was: detach($id, CallbackHandler $listener) : bool where: $id was a string identifier $listener was a CallbackHandler instance the method returned a boolean indicating whether or not it removed anything. The v3 signature becomes: detach(callable $listener, $identifier = null, $eventName = null) : void where: $listener is the callable listener you wish to remove $identifier , if provided, is a specific identifier from which you want to remove the $listener . $eventName , if provided, is a specific event on the specified $id from which to remove the $listener the method no longer returns a value. When not specifying an identifier, the method contract indicates it should remove the listener from any identifier; similarly, in the absence of an event argument, it should remove the listener from any event on the identifier(s). This allows for mass removal! As the signatures differ, you will need to update any code calling detach() after upgrading to v3. At the minimum, you will need to swap the $identifier and $listener arguments, and pass the callable listener instead of a CallbackHandler instance. We also recommend auditing your code to determine if you want to be more or less specific when detaching the listener.","title":"SharedEventManagerInterface::detach()"},{"location":"migration/changed/#listeneraggregateinterfaceattach","text":"Zend\\EventManager\\ListenerAggregateInterface::attach() was updated to add an optional argument, $priority = 1 . This codifies how the EventManager was already implemented. Since PHP allows adding optional arguments to concrete implementations of abstract methods, you can forward-proof your existing ListenerAggregateInterface implementations by adding the argument. As an example, if you define your method like this: public function attach(EventManagerInterface $events) Simply change it to this: public function attach(EventManagerInterface $events, $priority = 1) You do not need to do anything with the $priority argument, though we recommend passing it as a default value if you are not specifying a priority for any listeners you attach.","title":"ListenerAggregateInterface::attach()"},{"location":"migration/changed/#filterinterfaceattach-and-detach","text":"Zend\\EventManager\\Filter\\FilterInterface::attach() and detach() have changed signatures. The originals were: attach($callback) : CallbackHandler detach(CallbackHandler $callback) : bool where $callback for attach() could be a callable or a CallbackHandler . The new signatures are: attach(callable $callback) : void detach(callable $filter) : bool Typical usage in v2 was to capture the return value of attach() and pass it to detach() , as attach() would create a CallbackHandler for you to later pass to detach() . Since we can now pass the original callable argument to detach() now, you can cache that value instead.","title":"FilterInterface::attach() and detach()"},{"location":"migration/changed/#filteriterator","text":"Zend\\EventManager\\Filter\\FilterIterator now defines/overrides the insert() method in order to validate the incoming value and ensure it is callable, raising an exception when it is not. This simplifies logic in FilterChain , as it no longer needs to check if a filter is callable at runtime. The main migration change at this time is to know that an InvalidArgumentException will now be thrown when adding filters to a filter chain, vs at runtime.","title":"FilterIterator"},{"location":"migration/changed/#responsecollectionsetstopped","text":"Zend\\EventManager\\ResponseCollection::setStopped() no longer implements a fluent interface.","title":"ResponseCollection::setStopped()"},{"location":"migration/intro/","text":"Migration In this guide you will find specifics regarding changes from version 2 to version 3 of zend-eventmanager, including recommendations for forward-proofing your v2 applications such that they will work under v3.","title":"Intro"},{"location":"migration/intro/#migration","text":"In this guide you will find specifics regarding changes from version 2 to version 3 of zend-eventmanager, including recommendations for forward-proofing your v2 applications such that they will work under v3.","title":"Migration"},{"location":"migration/removed/","text":"Removed Functionality The following interfaces, classes, and methods have been removed for version 3. GlobalEventManager and StaticEventManager Zend\\EventManager\\GlobalEventManager and Zend\\EventManager\\StaticEventManager were removed, and there are no replacements. Global static state is generally considered a dangerous practice due to the side effects it can create, and we felt it was better to remove the option from the framework entirely. ProvidesEvents The trait Zend\\EventManager\\ProvidesEvents has been deprecated for most of the 2.0 series; use Zend\\EventManager\\EventManagerAwareTrait instead. EventManagerInterface::setSharedManager() We have removed EventManagerInterface::setSharedManager() , and also removed it from the EventManager implementation. The SharedEventManager should be injected during instantiation now. EventManagerInterface::getEvents() and getListeners() We have removed both EventManagerInterface::getEvents() and getListeners() , as we did not have a stated use case for the methods. The event manager should be something that aggregates listeners and triggers events; the details of what listeners or events are attached is largely irrelevant. The primary use case for getListeners() is often to determine if a listener is attached before detaching it. Since detach() acts as a no-op if the provided listener is not present, checking for presence first is not necessary. EventManagerInterface::setEventClass() The method EventManagerInterface::setEventClass() was removed and replaced with EventManagerInterface::setEventPrototype() , which has the following signature: setEventPrototype(EventInterface $event); This was done to prevent errors that occurred when invalid event class names were provided. Additionally, internally, event managers will clone the instance any time trigger() or triggerUntil() are called \u2014 which is typically faster and less resource intensive than instantiating a new instance. EventManagerInterface::attachAggregate() and detachAggregate() The methods attachAggregate() and detachAggregate() were removed from the EventManagerInterface and concrete EventManager implementation. Furthermore, attach() and detach() no longer handle aggregates. The reason they were removed is because they simply proxied to the attach() and detach() methods of the ListenerAggregateInterface . As such, to forward-proof your applications, you can alter statements that attach aggregates to an event manager reading as follows: $events->attach($aggregate); // or $events->attachAggregate($aggregate); to: $aggregate->attach($events); Similarly, for detaching an aggregate, migrate from: $events->detach($aggregate); // or $events->detachAggregate($aggregate); to: $aggregate->detach($events); The above works in all released versions of the component. SharedEventAggregateAwareInterface, SharedListenerAggregateInterface The interfaces Zend\\EventManager\\SharedEventAggregateAwareInterface and SharedListenerAggregateInterface were removed, as the concept of shared listener aggregates was removed from version 3. Migration will depend on what you have done in your application: extending the SharedEventManager and/or implementing SharedEventAggregateAwareInterface , or implementing SharedListenerAggregateInterface . SharedEventAggregateAwareInterface Zend\\EventManager\\SharedEventAggregateAwareInterface was added mid-way through the v2 lifecycle to allow adding shared listener aggregates to the SharedEventManager . If you were extending the SharedEventManager and overriding the methods defined in SharedEventAggregateAwareInterface , you should remove them. If you were implementing SharedEventAggregateAwareInterface , the interface no longer exists, and you should likely remove your implementation. SharedListenerAggregateInterface For those implementing shared listener aggregates, you can continue to use them, but will need to change how you do so. To migrate, you have two steps to take: remove the SharedListenerAggregateInterface implementation declaration from your aggregate class, and swap attachment of the aggregate. To accomplish the first step, keep the attachShared() and detachShared() methods in your class, but remove the implements SharedListenerAggregateInterface from the class declaration. For instance, if you had the following: namespace Foo; use Zend\\EventManager\\SharedEventManagerInterface; use Zend\\EventManager\\SharedListenerAggregateInterface; class MySharedAggregate implements SharedListenerAggregateInterface { public function attachShared(SharedEventManagerInterface $manager) { // ... } public function detachShared(SharedEventManagerInterface $manager) { // ... } } then modify it to instead read: namespace Foo; use Zend\\EventManager\\SharedEventManagerInterface; class MySharedAggregate { public function attachShared(SharedEventManagerInterface $manager) { // ... } public function detachShared(SharedEventManagerInterface $manager) { // ... } } For the second step, instead of attaching the aggregate to the shared event manager, you will pass the shared event manager to your aggregate. For example, if you had the following in your code: $sharedEvents->attachAggregate($mySharedAggregate); then you can change it to: $mySharedAggregate->attachShared($sharedEvents); This has exactly the same effect, and makes your code forward-compatible with v3. SharedEventManagerAwareInterface The interface Zend\\EventManager\\SharedEventManagerAwareInterface was removed, as version 3 now requires tha the SharedEventManagerInterface instance be injected into the EventManager instance at instantiation. A new interface, Zend\\EventManager\\SharedEventsCapableInterface , provides the getSharedManager() method, and EventManagerInterface extends it. To migrate, you have the following options: If you are only interested in the getSharedManager() method, you can implement SharedEventsCapableInterface starting with version 2.6.0. If you do this, you can also safely remove the setSharedManager() method from your implementation. If you will require injecting the shared manager, use duck typing to determine if a class has the setSharedManager() method: if (method_exists($instance, 'setSharedManager')) { $instance->setSharedManager($sharedEvents); } Alternately, if you control instantiation of the instance, consider injection at instantiation, or within the factory used to create your instance. SharedEventManagerInterface::getEvents() The method SharedEventManagerInterface::getEvents() was removed. The method was not consumed by the event manager, and served no real purpose.","title":"Removed Functionality"},{"location":"migration/removed/#removed-functionality","text":"The following interfaces, classes, and methods have been removed for version 3.","title":"Removed Functionality"},{"location":"migration/removed/#globaleventmanager-and-staticeventmanager","text":"Zend\\EventManager\\GlobalEventManager and Zend\\EventManager\\StaticEventManager were removed, and there are no replacements. Global static state is generally considered a dangerous practice due to the side effects it can create, and we felt it was better to remove the option from the framework entirely.","title":"GlobalEventManager and StaticEventManager"},{"location":"migration/removed/#providesevents","text":"The trait Zend\\EventManager\\ProvidesEvents has been deprecated for most of the 2.0 series; use Zend\\EventManager\\EventManagerAwareTrait instead.","title":"ProvidesEvents"},{"location":"migration/removed/#eventmanagerinterfacesetsharedmanager","text":"We have removed EventManagerInterface::setSharedManager() , and also removed it from the EventManager implementation. The SharedEventManager should be injected during instantiation now.","title":"EventManagerInterface::setSharedManager()"},{"location":"migration/removed/#eventmanagerinterfacegetevents-and-getlisteners","text":"We have removed both EventManagerInterface::getEvents() and getListeners() , as we did not have a stated use case for the methods. The event manager should be something that aggregates listeners and triggers events; the details of what listeners or events are attached is largely irrelevant. The primary use case for getListeners() is often to determine if a listener is attached before detaching it. Since detach() acts as a no-op if the provided listener is not present, checking for presence first is not necessary.","title":"EventManagerInterface::getEvents() and getListeners()"},{"location":"migration/removed/#eventmanagerinterfaceseteventclass","text":"The method EventManagerInterface::setEventClass() was removed and replaced with EventManagerInterface::setEventPrototype() , which has the following signature: setEventPrototype(EventInterface $event); This was done to prevent errors that occurred when invalid event class names were provided. Additionally, internally, event managers will clone the instance any time trigger() or triggerUntil() are called \u2014 which is typically faster and less resource intensive than instantiating a new instance.","title":"EventManagerInterface::setEventClass()"},{"location":"migration/removed/#eventmanagerinterfaceattachaggregate-and-detachaggregate","text":"The methods attachAggregate() and detachAggregate() were removed from the EventManagerInterface and concrete EventManager implementation. Furthermore, attach() and detach() no longer handle aggregates. The reason they were removed is because they simply proxied to the attach() and detach() methods of the ListenerAggregateInterface . As such, to forward-proof your applications, you can alter statements that attach aggregates to an event manager reading as follows: $events->attach($aggregate); // or $events->attachAggregate($aggregate); to: $aggregate->attach($events); Similarly, for detaching an aggregate, migrate from: $events->detach($aggregate); // or $events->detachAggregate($aggregate); to: $aggregate->detach($events); The above works in all released versions of the component.","title":"EventManagerInterface::attachAggregate() and detachAggregate()"},{"location":"migration/removed/#sharedeventaggregateawareinterface-sharedlisteneraggregateinterface","text":"The interfaces Zend\\EventManager\\SharedEventAggregateAwareInterface and SharedListenerAggregateInterface were removed, as the concept of shared listener aggregates was removed from version 3. Migration will depend on what you have done in your application: extending the SharedEventManager and/or implementing SharedEventAggregateAwareInterface , or implementing SharedListenerAggregateInterface .","title":"SharedEventAggregateAwareInterface, SharedListenerAggregateInterface"},{"location":"migration/removed/#sharedeventaggregateawareinterface","text":"Zend\\EventManager\\SharedEventAggregateAwareInterface was added mid-way through the v2 lifecycle to allow adding shared listener aggregates to the SharedEventManager . If you were extending the SharedEventManager and overriding the methods defined in SharedEventAggregateAwareInterface , you should remove them. If you were implementing SharedEventAggregateAwareInterface , the interface no longer exists, and you should likely remove your implementation.","title":"SharedEventAggregateAwareInterface"},{"location":"migration/removed/#sharedlisteneraggregateinterface","text":"For those implementing shared listener aggregates, you can continue to use them, but will need to change how you do so. To migrate, you have two steps to take: remove the SharedListenerAggregateInterface implementation declaration from your aggregate class, and swap attachment of the aggregate. To accomplish the first step, keep the attachShared() and detachShared() methods in your class, but remove the implements SharedListenerAggregateInterface from the class declaration. For instance, if you had the following: namespace Foo; use Zend\\EventManager\\SharedEventManagerInterface; use Zend\\EventManager\\SharedListenerAggregateInterface; class MySharedAggregate implements SharedListenerAggregateInterface { public function attachShared(SharedEventManagerInterface $manager) { // ... } public function detachShared(SharedEventManagerInterface $manager) { // ... } } then modify it to instead read: namespace Foo; use Zend\\EventManager\\SharedEventManagerInterface; class MySharedAggregate { public function attachShared(SharedEventManagerInterface $manager) { // ... } public function detachShared(SharedEventManagerInterface $manager) { // ... } } For the second step, instead of attaching the aggregate to the shared event manager, you will pass the shared event manager to your aggregate. For example, if you had the following in your code: $sharedEvents->attachAggregate($mySharedAggregate); then you can change it to: $mySharedAggregate->attachShared($sharedEvents); This has exactly the same effect, and makes your code forward-compatible with v3.","title":"SharedListenerAggregateInterface"},{"location":"migration/removed/#sharedeventmanagerawareinterface","text":"The interface Zend\\EventManager\\SharedEventManagerAwareInterface was removed, as version 3 now requires tha the SharedEventManagerInterface instance be injected into the EventManager instance at instantiation. A new interface, Zend\\EventManager\\SharedEventsCapableInterface , provides the getSharedManager() method, and EventManagerInterface extends it. To migrate, you have the following options: If you are only interested in the getSharedManager() method, you can implement SharedEventsCapableInterface starting with version 2.6.0. If you do this, you can also safely remove the setSharedManager() method from your implementation. If you will require injecting the shared manager, use duck typing to determine if a class has the setSharedManager() method: if (method_exists($instance, 'setSharedManager')) { $instance->setSharedManager($sharedEvents); } Alternately, if you control instantiation of the instance, consider injection at instantiation, or within the factory used to create your instance.","title":"SharedEventManagerAwareInterface"},{"location":"migration/removed/#sharedeventmanagerinterfacegetevents","text":"The method SharedEventManagerInterface::getEvents() was removed. The method was not consumed by the event manager, and served no real purpose.","title":"SharedEventManagerInterface::getEvents()"}]}